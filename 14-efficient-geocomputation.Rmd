# Efficient Geocomputation

## Prerequisites {-}

## Introduction

So far, this book has demonstrated geocomputation with relatively small data sets, this may have given the impression that geocomputation can be done quickly. However, as you move from examples to real problems you may find that the amount of data and thus the time to process increases significantly. In the worst cases your computer may fail to complete the task, run out of memory, or crash. This chapter will introduce some technique you may use to boost the performance of large or complex geocomputations.

## Benchmarking
When thinking about efficient programming it is important to have a “what works” attitude. You may come across programmers that insist that “X is always better than Y”, this is rarely true. Therefore, it is necessary to test different methods and compare their performance. 
### Sys.Time()
A really simple way to measure the time a chunk of code takes to run is to simple record the time before and after. The `Sys.Time()` function returns the current date and time. While the `difftime()` function returns the difference between two times.
```{r}
t1 = Sys.time()
## Arbitrary Code that takes some time to run
x = runif(1000000)
x = sqrt(x)
##
t2 = Sys.time()
difftime(t2,t1, units = "secs")
```
If you run this code several times you will notice that the run time varies slightly. This is due to your computer having other processing to do for other application you may have running or merely the background requirements of the operating system. 
While `Sys.Time()` is very simple it is not a great way to benchmark code as most functions take milliseconds to run not seconds. 

### microbenchmark
The microbenchmark package is designed to give a quick way to test different code chunks and get a measure of the average performance.

```{r}
library(microbenchmark)
x = runif(1000000)
microbenchmark(sqrt(x),  x ^ 0.5, times = 100) #Two methods for calculating the square root of a number
```
Running multiple tests gives greater confidence that the observed different in performance is representative.  In this case ` sqrt(x)` is much faster than ` x ^ 0.5` this illustrates the kinds of small changes that you can make to your code to achieve significant improvements in overall performance.

### Profvis
The profvis package produces graphs showing the time to execute each line of your code. This can be particularly helpful in identifying where you should focus your optimisation efforts.
 

## Iteration with Spatial Data
### Vectorisation (Why Iteration has not come up earlier)
Iteration (doing the same thing multiple times) is extremely common in programming. But can be introduce quite late in the process of learning R. This is because R is a vectorised language, and thus can easily handle long vectors or variables as well as single variables. 
Consider thing simple example:
```{r}
x = 5
sqrt(x)
y = c(5,10,15,20)
sqrt(y)

```
The same is true of many spatial functions such as `st_buffer()` which can create a buffer around a single geometry or many geometries. However in the background the `st_buffer()` function is working along a list of geometries performing the same task again and again. Finally, the function puts all the individual results together into a single object and returns them to you.
Vectorisation in R is very efficient, and very easy to use, but you may eventually come to a problem which cannot be done in a single vectorised step and must instead iterate along a list of geometries.
The reason iteration matters for efficient geocomputation is that price of code that you iterate over may be run thousands or millions of times, thus millisecond gains in a price of code can multiplied to hours or days of processing time by iteration. 
### Is iteration necessary
As iteration can have potentially high computation costs, it is always worth asking if iteration is necessary. The is an old story in mathematics that as a child Gauss was set a pointless task by his teacher to add the numbers 1 to 100. This was intended to keep the children occupied, and is a good example of an iterative task. 
1 + 2 = 3
3 + 3 = 6
6 + 4 = 10 
And so on
However, so the story goes, Gauss realised that there is short cut. For any list of positive integers from 1 to n:
S = n(n + 1) / 2
There is no need to go into the detail of the mathematics here merely to show that we can benchmark the two solutions in R. In this case I have increased the problem from 1:100 to 1:10000 to account of the greater performance of your computer.
```{r}
sum(1:10000) == 10000*(10000+1)/2 # Check the result is the same
microbenchmark(sum(1:10000),  10000*(10000+1)/2, times = 100) # Compare the performance
```
This simple example is to show that if iteration can be avoided it will usually offer far greater performance gains that even the most optimised of iterative processes.

### Iteration with for loops
The simples form of iteration is the for loop.

```{r}
for(i in 1:10){
  print(i)
}
```
If you are not familiar with loops read http://r4ds.had.co.nz/iteration.html#for-loops 
Looping across spatial data using the ***sf*** package is very similar to working with any other form of data in R. Therefore, let introduce a complex spatial problem as a way to show some good and bad ways to solve it.
Using the cycle_hire data from the spData package. Gives me a data.frame of points representing the location of cycle hire stands in London.

```{r}
library(spData)
points <- cycle_hire
plot(points$geometry)
```
The task to perform is:
1)	For points that have no empty spaces buffer a circle around the point with radius equal to the number of bikes;
2)	For points with some empty space construct a square around the point with width equate to the number of bikes;
3)	For point will all empty spaces construct an equilateral triangle around the point with sides length equal to the number of empty spaces;
This is clearly not a very useful task, but is has characteristics of a complex geocomputation. 
1)	It has conditions: the nature of the geocomputation varies based on the input data;
2)	It is based on multiple variables from a data.frame;
3)	It requires a multi-step process;
4)	It requires a non-standard geometric operation (constructing a triangle centred on a point)
Let’s start by constructing the basic structure of a for loop to solve this problem 

```{r}
for(i in seq_along(points$id)){ #Loop along each row of the points data.frame
  #Get the number of bikes and spaces for the current row
  bikes = points$nbikes[i]
  empty = points$nempty[i]
  
  #If Else statement to decide what to do
  if(empty == 0){
    #Make a Circle
    print("Make a circle")
  }else if (bikes == 0){
    #Make a triangle
    print("Make a triangle")
  }else if (bikes != 0 & empty != 0){
    #make a square
    print("Make a square")
  }else{
    #This case should never occur, so if it does stop and return an error message
    warning(paste0("Unexpected case for bikes and empty in row ",i))
    stop()
  }

}

```
So far there is no geocomputation, just the simple logic of which type of shape we should generate and the for loop. Notice that the code fetches the relevant variables from the data.frame and stores them as new variables bikes and empty. If you are working on very large data.frame and need to make multiple checks on a value within your loop, creating a new temporary variable may save time. Also notice that the last else statement concerns a case that should never happen. This can be helpful in debugging complex operation where an unexpected value or combination of values appears within a large data.frame.
Now lets add in the construction of the shapes

```{r}
library(sf)
library(tmap)
tmap_mode("view")
points.proj <- st_transform(points, 27700) #Convert to a projected coordinate system (British National Grid)
shapes <- list()
for(i in seq_along(points$id)){ #Loop along each row of the points data.frame
  #Get the number of bikes and spaces for the current row
  bikes = points.proj$nbikes[i]
  empty = points.proj$nempty[i]
  point = points.proj$geometry[i]
  
  #If Else statement to decide what to do
  if(empty == 0){
    #Make a Circle
    pol = st_buffer(point, bikes)
    pol = pol[[1]]
  }else if (bikes == 0){
    #Make a triangle
    #Extract the coordinate from the point
    x = as.numeric(point[[1]])[1]
    y = as.numeric(point[[1]])[2]
    
    #Calculate x & y coordinate of the corner of the triangle
    a_x = x + empty/2
    a_y = y - empty/(2 * sqrt(3))
    b_x = x - empty/2
    b_y = y - empty/(2 * sqrt(3))
    c_x = x
    c_y = y + ( sqrt(0.75 * empty ^2) - (empty/(2 * sqrt(3))) )
    
    #Make the polygon
    pol = st_polygon(list(rbind( c(a_x, a_y), c(b_x, b_y), c(c_x, c_y), c(a_x, a_y) )))
    
  }else if (bikes != 0 & empty != 0){
    #make a square
    #Extract the coordinate from the point
    x = as.numeric(point[[1]])[1]
    y = as.numeric(point[[1]])[2]
    
    #Get the coordiante of the sqaure
    xmin = x - bikes/2
    xmax = x + bikes/2
    ymin = y - bikes/2
    ymax = y + bikes/2
    
    #Make the polygon
    pol = st_polygon(list(rbind( c(xmin, ymin), c(xmin, ymax), c(xmax, ymax), c(xmax, ymin), c(xmin, ymin) )))
    
  }else{
    #This case should never occur, so if it does stop and return an error message
    warning(paste0("Unexpected case for bikes and empty in row ",i))
    stop()
  }
  
  #Add the results to a list
  shapes[[i]] = pol

}

result = data.frame(id = points$id, geometry = NA)
result$geometry <- st_sfc(shapes)
st_geometry(result) = result$geometry
st_crs(result) = 27700
result = st_transform(result, 4326) #Convert resutls back to latitutes and logitudes

qtm(result)

```
Lets look at each part of the code in turn.
Before the Loop
We convert the points to a projected coordinate system, as this makes subsequent calculations easier, and we do thins outside of the loop as `st_transform` is a vectorised function and we can take advantage of the performance gain from using vectorisation. 
We also create an empty list `shapes` for the results to be inserted into. 
Making a Circle
This is the simplest case a we can simply call the `st_buffer` function. But notice that the class of `pol` is "sfc_POLYGON" "sfc". In other words, it a set of geometries that happens to only contain a single geometry. When we construct the triangles and square later in the code the are single geometries. So for consistency `pol = pol[[1]]` extracts the raw geometry from the list. 
Making the Triangle
Note the use of [] to delve deep into the structure of a spatial object and extract out the raw numerical values. We then construct the x & y coordinate for each point on the triangle. An optional exercise is to establish the geometric rules used to construct the triangle. Finally, the x & y coordinate are assembled into a polygon. Notice that coordinates are not passed directly to `st_polygon` but instead are made into a list of matrices. 
Making the Square
Similar to making the triangle, but with simpler geometric rules.
Exporting the results
Each resulting polygon is added to the list `shapes`. 
After the loop
A data.frame is constructed and the list of geometries are added to the data.frame. `st_geometry(result) = result$geometry` Ideified this column to R as a geometry column and converts from data.frame to a sf data.frame.
As the geometries we created are raw they do not have a CRS, but they used the CRS of the British National Grid in the calculation (27700) so the CRS can be assigned. Note that we assign the British national grid before transforming back to latitude and longitudes (4326).
Finally we check the results using tmap
## Functional Iteration
This code is not optimal there are a number of place where identical calculation are made repeatedly (e.g. `2 * sqrt(3)` ) as well as duplication between the triangle and square part of the code that could be reduced. It will suffice as a test bed to demonstrate techniques for increasing the performance of your code.
### from loops to functions
While loops are conceptually simple to create they are difficult to integrate with other code. Especially if you start having loops within loops. An excellent way to reduce the complexity is to create functions which contain your loops. This may not provide an inherent speed boost but is a pre-requisite for later improvements. For more information on function writing see http://r4ds.had.co.nz/iteration.html#for-loops-vs.functionals
Proper functions should take in inputs and return outputs without having to refer to the outside world. However, the flexibility of R allows functions to access global variable from within a function. This can allow a loop to be turned into a function with minimal rewriting of the code.

```{r}
library(sf)
library(tmap)
tmap_mode("view")
points.proj <- st_transform(points, 27700) #Convert to a projected coordinate system (British National Grid)
shapes <- list()

points2shapes <- function(i){
  #Get the number of bikes and spaces for the current row
  bikes = points.proj$nbikes[i]
  empty = points.proj$nempty[i]
  point = points.proj$geometry[i]
  
  #If Else statement to decide what to do
  if(empty == 0){
    #Make a Circle
    pol = st_buffer(point, bikes)
    pol = pol[[1]]
  }else if (bikes == 0){
    #Make a triangle
    #Extract the coordinate from the point
    x = as.numeric(point[[1]])[1]
    y = as.numeric(point[[1]])[2]
    
    #Calculate x & y coordinate of the corner of the triangle
    a_x = x + empty/2
    a_y = y - empty/(2 * sqrt(3))
    b_x = x - empty/2
    b_y = y - empty/(2 * sqrt(3))
    c_x = x
    c_y = y + ( sqrt(0.75 * empty ^2) - (empty/(2 * sqrt(3))) )
    
    #Make the polygon
    pol = st_polygon(list(rbind( c(a_x, a_y), c(b_x, b_y), c(c_x, c_y), c(a_x, a_y) )))
    
  }else if (bikes != 0 & empty != 0){
    #make a square
    #Extract the coordinate from the point
    x = as.numeric(point[[1]])[1]
    y = as.numeric(point[[1]])[2]
    
    #Get the coordiante of the sqaure
    xmin = x - bikes/2
    xmax = x + bikes/2
    ymin = y - bikes/2
    ymax = y + bikes/2
    
    #Make the polygon
    pol = st_polygon(list(rbind( c(xmin, ymin), c(xmin, ymax), c(xmax, ymax), c(xmax, ymin), c(xmin, ymin) )))
    
  }else{
    #This case should never occur, so if it does stop and return an error message
    warning(paste0("Unexpected case for bikes and empty in row ",i))
    stop()
  }
  
  return(pol)

}



```


## Parallelisation
