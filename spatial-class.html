<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Geocomputation with R</title>
  <meta name="description" content="Forthcoming book on geographical data with R.">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Geocomputation with R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://robinlovelace.net/geocompr" />
  
  <meta property="og:description" content="Forthcoming book on geographical data with R." />
  <meta name="github-repo" content="Robinlovelace/geocompr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Geocomputation with R" />
  
  <meta name="twitter:description" content="Forthcoming book on geographical data with R." />
  

<meta name="author" content="Robin Lovelace">
<meta name="author" content="Jakub Nowosad">


<meta name="date" content="2017-08-24">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="intro.html">
<link rel="next" href="attr.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-0.9/htmlwidgets.js"></script>
<link href="libs/leaflet-0.7.7/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-0.7.7/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<link href="libs/leaflet-label-0.2.2/leaflet.label.css" rel="stylesheet" />
<script src="libs/leaflet-label-0.2.2/leaflet.label.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4-compressed.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4leaflet.js"></script>
<script src="libs/leaflet-binding-1.1.0/leaflet.js"></script>
<script src="libs/leaflet-providers-1.0.27/leaflet-providers.js"></script>
<script src="libs/leaflet-providers-plugin-1.1.0/leaflet-providers-plugin.js"></script>
<link href="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.css" rel="stylesheet" />
<script src="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99618359-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Geocomputation with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#development"><i class="fa fa-check"></i>Development</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#reproducibility"><i class="fa fa-check"></i>Reproducibility</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#what-is-geocomputation"><i class="fa fa-check"></i><b>1.1</b> What is geocomputation?</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#why-geocomputation-with-r"><i class="fa fa-check"></i><b>1.2</b> Why Geocomputation with R?</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#software-for-geocomputation"><i class="fa fa-check"></i><b>1.3</b> Software for geocomputation</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#rs-spatial-ecosystem"><i class="fa fa-check"></i><b>1.4</b> R’s spatial ecosystem</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#rs-spatial-history"><i class="fa fa-check"></i><b>1.5</b> R’s spatial history</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="spatial-class.html"><a href="spatial-class.html"><i class="fa fa-check"></i><b>2</b> Geographic data in R</a><ul>
<li class="chapter" data-level="" data-path="spatial-class.html"><a href="spatial-class.html#prerequisites"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="2.1" data-path="spatial-class.html"><a href="spatial-class.html#vector-data"><i class="fa fa-check"></i><b>2.1</b> Vector data</a><ul>
<li class="chapter" data-level="2.1.1" data-path="spatial-class.html"><a href="spatial-class.html#intro-sf"><i class="fa fa-check"></i><b>2.1.1</b> An introduction to simple features</a></li>
<li class="chapter" data-level="2.1.2" data-path="spatial-class.html"><a href="spatial-class.html#why-simple-features"><i class="fa fa-check"></i><b>2.1.2</b> Why Simple Features?</a></li>
<li class="chapter" data-level="2.1.3" data-path="spatial-class.html"><a href="spatial-class.html#basic-map"><i class="fa fa-check"></i><b>2.1.3</b> Basic map making</a></li>
<li class="chapter" data-level="2.1.4" data-path="spatial-class.html"><a href="spatial-class.html#sf_classes"><i class="fa fa-check"></i><b>2.1.4</b> Simple feature classes</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="spatial-class.html"><a href="spatial-class.html#raster-data"><i class="fa fa-check"></i><b>2.2</b> Raster data</a><ul>
<li class="chapter" data-level="2.2.1" data-path="spatial-class.html"><a href="spatial-class.html#an-introduction-to-raster"><i class="fa fa-check"></i><b>2.2.1</b> An introduction to raster</a></li>
<li class="chapter" data-level="2.2.2" data-path="spatial-class.html"><a href="spatial-class.html#basic-map-making"><i class="fa fa-check"></i><b>2.2.2</b> Basic map making</a></li>
<li class="chapter" data-level="2.2.3" data-path="spatial-class.html"><a href="spatial-class.html#raster-classes"><i class="fa fa-check"></i><b>2.2.3</b> Raster classes</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="spatial-class.html"><a href="spatial-class.html#coordinate-reference-systems"><i class="fa fa-check"></i><b>2.3</b> Coordinate Reference Systems</a></li>
<li class="chapter" data-level="2.4" data-path="spatial-class.html"><a href="spatial-class.html#units"><i class="fa fa-check"></i><b>2.4</b> Units</a></li>
<li class="chapter" data-level="2.5" data-path="spatial-class.html"><a href="spatial-class.html#exercises-1"><i class="fa fa-check"></i><b>2.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="attr.html"><a href="attr.html"><i class="fa fa-check"></i><b>3</b> Attribute data operations</a><ul>
<li class="chapter" data-level="" data-path="attr.html"><a href="attr.html#prerequisites-1"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="3.1" data-path="attr.html"><a href="attr.html#introduction"><i class="fa fa-check"></i><b>3.1</b> Introduction</a></li>
<li class="chapter" data-level="3.2" data-path="attr.html"><a href="attr.html#attribute-subsetting"><i class="fa fa-check"></i><b>3.2</b> Attribute subsetting</a></li>
<li class="chapter" data-level="3.3" data-path="attr.html"><a href="attr.html#attribute-data-aggregation"><i class="fa fa-check"></i><b>3.3</b> Attribute data aggregation</a></li>
<li class="chapter" data-level="3.4" data-path="attr.html"><a href="attr.html#attribute-data-joining"><i class="fa fa-check"></i><b>3.4</b> Attribute data joining</a><ul>
<li class="chapter" data-level="3.4.1" data-path="attr.html"><a href="attr.html#left-joins"><i class="fa fa-check"></i><b>3.4.1</b> Left joins</a></li>
<li class="chapter" data-level="3.4.2" data-path="attr.html"><a href="attr.html#inner-joins"><i class="fa fa-check"></i><b>3.4.2</b> Inner joins</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="attr.html"><a href="attr.html#attribute-data-creation"><i class="fa fa-check"></i><b>3.5</b> Attribute data creation</a></li>
<li class="chapter" data-level="3.6" data-path="attr.html"><a href="attr.html#removing-spatial-information"><i class="fa fa-check"></i><b>3.6</b> Removing spatial information</a></li>
<li class="chapter" data-level="3.7" data-path="attr.html"><a href="attr.html#exercises-2"><i class="fa fa-check"></i><b>3.7</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html"><i class="fa fa-check"></i><b>4</b> Spatial data operations</a><ul>
<li class="chapter" data-level="" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#prerequisites-2"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="4.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#introduction-1"><i class="fa fa-check"></i><b>4.1</b> Introduction</a></li>
<li class="chapter" data-level="4.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-subsetting"><i class="fa fa-check"></i><b>4.2</b> Spatial subsetting</a><ul>
<li class="chapter" data-level="" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#note"><i class="fa fa-check"></i>Note</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-data-aggregation"><i class="fa fa-check"></i><b>4.3</b> Spatial data aggregation</a><ul>
<li class="chapter" data-level="4.3.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-congruence-and-areal-interpolation"><i class="fa fa-check"></i><b>4.3.1</b> Spatial congruence and areal interpolation</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-data-joining"><i class="fa fa-check"></i><b>4.4</b> Spatial data joining</a></li>
<li class="chapter" data-level="4.5" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-data-creation"><i class="fa fa-check"></i><b>4.5</b> Spatial data creation</a><ul>
<li class="chapter" data-level="4.5.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#topological-relations"><i class="fa fa-check"></i><b>4.5.1</b> Topological relations</a></li>
<li class="chapter" data-level="4.5.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#distance-relations"><i class="fa fa-check"></i><b>4.5.2</b> Distance relations</a></li>
<li class="chapter" data-level="4.5.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-clipping"><i class="fa fa-check"></i><b>4.5.3</b> Spatial clipping</a></li>
<li class="chapter" data-level="4.5.4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#exercises-3"><i class="fa fa-check"></i><b>4.5.4</b> Exercises</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="read-write.html"><a href="read-write.html"><i class="fa fa-check"></i><b>5</b> Geographic data I/O</a><ul>
<li class="chapter" data-level="5.1" data-path="read-write.html"><a href="read-write.html#data-input-i"><i class="fa fa-check"></i><b>5.1</b> Data Input (I)</a></li>
<li class="chapter" data-level="5.2" data-path="read-write.html"><a href="read-write.html#data-output-o"><i class="fa fa-check"></i><b>5.2</b> Data output (O)</a></li>
<li class="chapter" data-level="5.3" data-path="read-write.html"><a href="read-write.html#file-formats"><i class="fa fa-check"></i><b>5.3</b> File formats</a></li>
<li class="chapter" data-level="5.4" data-path="read-write.html"><a href="read-write.html#visual-outputs"><i class="fa fa-check"></i><b>5.4</b> Visual outputs</a></li>
<li class="chapter" data-level="5.5" data-path="read-write.html"><a href="read-write.html#exercises-4"><i class="fa fa-check"></i><b>5.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>6</b> References</a></li>
<li class="divider"></li>
<li><a href="http://robinlovelace.net/">Robin Lovelace</a></li>
<li><a href="https://nowosad.github.io/">Jakub Nowosad</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Geocomputation with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="spatial-class" class="section level1">
<h1><span class="header-section-number">2</span> Geographic data in R</h1>
<div id="prerequisites" class="section level2 unnumbered">
<h2>Prerequisites</h2>
<p>This is the first practical chapter of book and therefore has software requirements. We assume you have a recent version of R installed on your computer and are comfortable using it at the command line, e.g. via an integrated development environment (IDE) such as RStudio (recommended). R/RStudio works on all major operating systems and can be installed and set-up in a few minutes on most modern computers, as described in <a href="https://csgillespie.github.io/efficientR/set-up.html#r-version">section 2.3</a> and <a href="https://csgillespie.github.io/efficientR/set-up.html#rstudio">section 2.5</a> of <span class="citation">Gillespie and Lovelace (<a href="#ref-gillespie_efficient_2016">2016</a>)</span> (other guides are available).</p>
<p>If you are not a regular R user is worth taking time to ensure that you have an efficient R workflow because this will make the subsequent worked examples easier to run on your own computer, e.g. as part of an RStudio ‘<a href="https://csgillespie.github.io/efficientR/set-up.html#project-management">project</a>’ such as that provided in the root directory of the <a href="https://github.com/Robinlovelace/geocompr"><code>geocompr</code></a> GitHub repository. We recommend getting up-to-speed with the language, with reference to resources such as <span class="citation">Gillespie and Lovelace (<a href="#ref-gillespie_efficient_2016">2016</a>)</span>, <span class="citation">Grolemund and Wickham (<a href="#ref-grolemund_r_2016">2016</a>)</span>, and online interactive guides such as that provided by <a href="https://www.datacamp.com/courses/free-introduction-to-r">DataCamp</a>, before proceeding with the chapter.</p>
<hr />
<p>After R is installed and set-up, packages which extend R must be installed and loaded for it to handle spatial data. On Mac and Linux operating systems there are a few additional requirements: see the <a href="https://github.com/r-spatial/sf">README</a> of the <strong>sf</strong> package for instructions. The <strong>sf</strong>, <strong>raster</strong>, <strong>spData</strong>, and <strong>spDataLarge</strong> packages used in this chapter can be installed and loaded with the following commands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;sf&quot;</span>)
<span class="kw">install.packages</span>(<span class="st">&quot;raster&quot;</span>)
<span class="kw">install.packages</span>(<span class="st">&quot;spData&quot;</span>)
<span class="kw">library</span>(sf)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(spData)
<span class="kw">install.packages</span>(<span class="st">&quot;spDataLarge&quot;</span>)
<span class="kw">library</span>(spDataLarge)</code></pre></div>
<p>This chapter will provide brief explanations of both the fundamental geographic data types: vector and raster. A brief abstract description is provided of each before moving quickly to their implementation in R packages designed specifically for handling them. Both are vital to the sciences, although which will be of most use will largely depend on your discipline:</p>
<ul>
<li>Because human settlements and boundaries tend to be complex with precise borders defined by legal systems, vector data tends to dominate in the social sciences.</li>
<li>In environmental sciences, by contrast, raster data tend to dominate due to its links to remote sensing.</li>
</ul>
<p>However, there is a substantial level of overlap: ecologists and demographers, for example, commonly use both vector and raster geographical data types. We therefore strongly recommend learning about each type of data before proceeding to understand how to manipulate them in subsequent chapters.</p>
</div>
<div id="vector-data" class="section level2">
<h2><span class="header-section-number">2.1</span> Vector data</h2>
<p>Vector data are based on points that are located on a Cartesian (or geographic) coordinate system. Each point in vector data is typically described by two numbers representing distance from the <span class="math inline">\(origin\)</span> along the <span class="math inline">\(x\)</span> (horizontal) and <span class="math inline">\(y\)</span> (vertical) axis in Euclidean space.<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> In mathematical notation these points are typically represented as numbers separated by commas and enclosed by a pair of brackets: <span class="math inline">\((1, 3)\)</span> for example, represents a point located one unit to the right and three units above the origin. There is clear link between these vector points and the <code>vector</code> class in R. The following line of code, for example, creates a 2 dimensional vector:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p =<span class="st"> </span><span class="kw">vector</span>(<span class="dt">mode =</span> <span class="st">&quot;numeric&quot;</span>, <span class="dt">length =</span> <span class="dv">2</span>)</code></pre></div>
<p>More commonly one would read-in data with functions such as <code>read_csv()</code> from the <strong>tidyverse</strong> or <code>read_sf()</code> from the <strong>sf</strong> package, covered in chapter <a href="read-write.html#read-write">5</a>. To generate new data (e.g. for testing), one would more commonly use the command <code>c()</code> (think of ‘c’ for ‘combine’), as illustrated below:<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p =<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>)</code></pre></div>
<p>Now this can be plotted in Cartesian space, as illustrated in figure <a href="spatial-class.html#fig:cartesian">2.1</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(p[<span class="dv">1</span>], p[<span class="dv">2</span>], <span class="dt">xlim =</span>  <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>), <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>))</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:cartesian"></span>
<img src="figures/cartesian-1.png" alt="Illustration of vector point data in base R." width="576" />
<p class="caption">
Figure 2.1: Illustration of vector point data in base R.
</p>
</div>
<p>Generally vector datasets have a high level of precision (but not necessarily accuracy as we will see in <a href="spatial-class.html#units">2.4</a>). Raster datasets, by contrast, use cells that break the surface up into a cells of constant size (<em>resolution</em>). Rasters therefore aggregate spatially specific features to a given resolution resulting in small features being blurred or lost in raster datasets. <!-- todo: add figure(s) showing raster data and blurring? --> This book uses <strong>sf</strong> and <strong>raster</strong> packages to work with vector data and raster datasets respectively.</p>
<div id="intro-sf" class="section level3">
<h3><span class="header-section-number">2.1.1</span> An introduction to simple features</h3>
<p>Simple features is an open standard developed and endorsed by the Open Geospatial Consortium (<a href="http://portal.opengeospatial.org/files/?artifact_id=25355">OGC</a>) to represent a wide range of geographical information. It is a hierarchical data model that simplifies geographic data by condensing a complex range of geographic forms into a single geometry class. Only 7 out of 68 possible types of simple feature are currently used in the vast majority of GIS operations (Figure <a href="spatial-class.html#fig:sf-ogc">2.2</a>). All of these are fully supported (with plotting methods etc) in the R package <strong>sf</strong> <span class="citation">(Pebesma <a href="#ref-R-sf">2017</a>)</span>.<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a></p>
<div class="figure" style="text-align: center"><span id="fig:sf-ogc"></span>
<img src="figures/sf-classes.png" alt="The subset of the Simple Features class hierarchy supported by sf. Figure based on the Open Geospatial Consortium document [06-103r4](http://www.opengeospatial.org/standards/sfa)." width="100%" />
<p class="caption">
Figure 2.2: The subset of the Simple Features class hierarchy supported by sf. Figure based on the Open Geospatial Consortium document <a href="http://www.opengeospatial.org/standards/sfa">06-103r4</a>.
</p>
</div>
<p><strong>sf</strong> can represent all common vector geometry types (raster data classes are not supported by <strong>sf</strong>): points, lines, polygons and their respective ‘multi’ versions (which group together features of the same type into a single feature). <strong>sf</strong> also supports geometry collections, which can contain multiple geometry types in a single feature. Given the breadth of geographic data forms, it may come as a surprise that a class system to support all of them is provided in a single package, which can be installed from CRAN:<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a> <strong>sf</strong> incorporates the functionality of the 3 main packages of the <strong>sp</strong> paradigm (<strong>sp</strong> <span class="citation">(Pebesma and Bivand <a href="#ref-R-sp">2017</a>)</span> for the class system, <strong>rgdal</strong> <span class="citation">(Bivand, Keitt, and Rowlingson <a href="#ref-R-rgdal">2017</a>)</span> for reading and writing data, <strong>rgeos</strong> <span class="citation">(Bivand and Rundel <a href="#ref-R-rgeos">2017</a>)</span> for spatial operations undertaken by GEOS) in a single, cohesive whole. This is well-documented in <strong>sf</strong>’s <a href="http://cran.rstudio.com/package=sf">vignettes</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vignette</span>(<span class="st">&quot;sf1&quot;</span>) <span class="co"># for an introduction to the package</span>
<span class="kw">vignette</span>(<span class="st">&quot;sf2&quot;</span>) <span class="co"># for reading, writing and converting Simple Features</span>
<span class="kw">vignette</span>(<span class="st">&quot;sf3&quot;</span>) <span class="co"># for manipulating Simple Features</span></code></pre></div>
<p>As the first vignette explains, simple feature objects in R are stored in a data frame, with geographic data occupying special column, a ‘list-column’. This column is usually named ‘geom’ or ‘geometry’. A ‘real world’ example is loaded by the <strong>spData</strong> package, which loads the <code>world</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spData)
<span class="kw">data</span>(<span class="st">&quot;world&quot;</span>)</code></pre></div>
<p>In the above code <strong>spData</strong> silently loaded the <code>world</code> dataset (and many other spatial datasets - see <a href="https://nowosad.github.io/spData/">the spData website</a> for a full list). The dataset contains spatial and non-spatial information, as shown by the function <code>names()</code>, which reports the column headings in data frames. This can be seen as the final column name of <code>world</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(world)
<span class="co">#&gt;  [1] &quot;iso_a2&quot;    &quot;name_long&quot; &quot;continent&quot; &quot;region_un&quot; &quot;subregion&quot;</span>
<span class="co">#&gt;  [6] &quot;type&quot;      &quot;area_km2&quot;  &quot;pop&quot;       &quot;lifeExp&quot;   &quot;gdpPercap&quot;</span>
<span class="co">#&gt; [11] &quot;geom&quot;</span></code></pre></div>
<p>It is the contents of this modest-looking <code>geom</code> column that gives <code>sf</code> objects their spatial powers. It’s actually a list-column, containing all the coordinates needed to plot the result as a map using the <code>plot()</code> method, the results of which are presented in Figure <a href="spatial-class.html#fig:world-all">2.3</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sf) <span class="co"># must be loaded to plot sf objects</span>
<span class="co">#&gt; Linking to GEOS 3.5.0, GDAL 2.1.0, proj.4 4.8.0</span>
<span class="kw">plot</span>(world)
<span class="co">#&gt; Warning: plotting the first 9 out of 10 attributes; use max.plot = 10 to</span>
<span class="co">#&gt; plot all</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:world-all"></span>
<img src="figures/world-all-1.png" alt="A spatial plot of the world using the sf package, with a facet for each attribute." width="576" />
<p class="caption">
Figure 2.3: A spatial plot of the world using the sf package, with a facet for each attribute.
</p>
</div>
<p>Note that instead of creating a single map, as most GIS programs would, the <code>plot()</code> command has created multiple maps, one for each variable in the <code>world</code> datasets. This behavior can be useful for exploring the spatial distribution of different variables and is discussed further in <a href="spatial-class.html#basic-map">2.1.3</a> below.</p>
<p>Being able to treat spatial objects as regular data frames with spatial powers has many advantages, especially if you are already used to working with data frames. The commonly used <code>summary()</code> function, for example, provides a useful overview of the variables within the <code>world</code> object, but prefixed with some information about the object’s spatial component:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(world[<span class="st">&quot;lifeExp&quot;</span>])
<span class="co">#&gt;     lifeExp                geom    </span>
<span class="co">#&gt;  Min.   :48.9   MULTIPOLYGON :177  </span>
<span class="co">#&gt;  1st Qu.:64.3   epsg:4326    :  0  </span>
<span class="co">#&gt;  Median :72.8   +proj=long...:  0  </span>
<span class="co">#&gt;  Mean   :70.6                      </span>
<span class="co">#&gt;  3rd Qu.:77.1                      </span>
<span class="co">#&gt;  Max.   :83.6                      </span>
<span class="co">#&gt;  NA&#39;s   :9</span></code></pre></div>
<p>The result provides a quick summary of both the non-spatial and spatial data contained in <code>world</code>: the average life expectancy is 73 years (ranging from less than 50 to more than 80 years) across all countries, and these are represented by <code>MULTIPOLYGON</code>s, allowing many polygons per country (this is needed for countries with many islands such as Indonesia and Greece).</p>
<!-- TODO: cross-reference section covering CRSs. -->
<p>Note that by appending <code>[&quot;lifeExp&quot;]</code> onto the object name in the previous code chunk, only the relevant column was summarized. We explore such ‘attribute operations’ in Chapter <a href="attr.html#attr">3</a>. First, it’s worth taking a look at the basic behavior and contents of this simple feature object, which can usefully be thought of as a ’<strong>S</strong>patial data<strong>F</strong>rame).</p>
<p><code>sf</code> objects are easy to subset. The code below shows its first 2 rows and 3 columns. The output shows 2 major differences compared with a regular <code>data.frame</code>: the inclusion of additional geographic data (<code>geometry type</code>, <code>dimension</code>, <code>bbox</code> and CRS information - <code>epsg (SRID)</code>, <code>proj4string</code>), and the presence of final <code>geometry</code> column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world[<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="dv">3</span>]
<span class="co">#&gt; Simple feature collection with 2 features and 3 fields</span>
<span class="co">#&gt; geometry type:  MULTIPOLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 11.6401 ymin: -17.93064 xmax: 75.15803 ymax: 38.48628</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt;   iso_a2   name_long continent                           geom</span>
<span class="co">#&gt; 1     AF Afghanistan      Asia MULTIPOLYGON(((61.210817091...</span>
<span class="co">#&gt; 2     AO      Angola    Africa MULTIPOLYGON(((16.326528354...</span></code></pre></div>
<p>All this may seem rather complex, especially for a class system that is supposed to be simple. However, there are good reasons for organizing things this way and using <strong>sf</strong>.</p>
<!-- It's a `MULTIPOLYGON` with 177 features and a geographical (longitude/latidue) coordinate reference system (CRS) with an EPSG code of `4326`. -->
</div>
<div id="why-simple-features" class="section level3">
<h3><span class="header-section-number">2.1.2</span> Why Simple Features?</h3>
<p>There are many advantages of <strong>sf</strong> over <strong>sp</strong>, including:</p>
<ul>
<li>Faster reading and writing of data (more than 10 times faster in some cases)</li>
<li>Better plotting performance</li>
<li><strong>sf</strong> objects can be treated as dataframes in most operations</li>
<li><strong>sf</strong> functions can be combined using <code>%&gt;%</code> operator and works well with the <a href="http://tidyverse.org/">tidyverse</a> collection of R packages</li>
<li><strong>sf</strong> function names are relatively consistent and intuitive (all begin with <code>st_</code>) compared with the function names and syntax of the <strong>sp</strong>, <strong>rgdal</strong> and <strong>rgeos</strong> packages that it supersedes.</li>
</ul>
<p>A broader advantage is that simple features are so well-supported by other software products, not least PostGIS, which has heavily influenced the design of <strong>sf</strong>.</p>
<p>A disadvantage you should be aware of, however, is that <strong>sf</strong> is not <em>feature complete</em> and that it continues to evolve. The transition from <strong>sp</strong> to <strong>sf</strong> will likely take many years, and many spatial packages may never switch. Even if you discover spatial data with R through the <strong>sf</strong> package, it is still worth at least being aware of <strong>sp</strong> classes, even if you rarely use them for everyday geospatial tasks.</p>
<p>Fortunately it is easy to translate between <strong>sp</strong> and <strong>sf</strong> using the <code>as()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sp)
world_sp =<span class="st"> </span><span class="kw">as</span>(<span class="dt">object =</span> world, <span class="dt">Class =</span> <span class="st">&quot;Spatial&quot;</span>)</code></pre></div>
</div>
<div id="basic-map" class="section level3">
<h3><span class="header-section-number">2.1.3</span> Basic map making</h3>
<p>Basic maps in <strong>sf</strong> can be created quickly with the base <code>plot()</code> function. Unlike <strong>sp</strong>, however, <strong>sf</strong> by default creates a faceted plot, one sub-plot for each variable, as illustrated in the left-hand image in Figure <a href="spatial-class.html#fig:sfplot">2.4</a>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(world[<span class="dv">3</span>:<span class="dv">4</span>])
<span class="kw">plot</span>(world[<span class="st">&quot;pop&quot;</span>])</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:sfplot"></span>
<img src="figures/sfplot-1.png" alt="Plotting with sf, with multiple variables (left) and a single variable (right)." width="49%" /><img src="figures/sfplot-2.png" alt="Plotting with sf, with multiple variables (left) and a single variable (right)." width="49%" />
<p class="caption">
Figure 2.4: Plotting with sf, with multiple variables (left) and a single variable (right).
</p>
</div>
<p>As with <strong>sp</strong>, you can add layers to your maps created with <code>plot()</code>, with the argument <code>add = TRUE</code>.<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a> To illustrate this, and prepare for content covered in chapters <a href="attr.html#attr">3</a> and <a href="spatial-data-operations.html#spatial-data-operations">4</a> on attribute and spatial data operations, we will subset and combine countries in the <code>world</code> object, to create a single object that represents Asia:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">asia =<span class="st"> </span>world[world$continent ==<span class="st"> &quot;Asia&quot;</span>, ]
asia =<span class="st"> </span><span class="kw">st_union</span>(asia)</code></pre></div>
<p>We can now plot the Asian continent over a map of the world. Note, however, that this only works if the initial plot has only 1 layer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(world[<span class="st">&quot;pop&quot;</span>])
<span class="kw">plot</span>(asia, <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<p><img src="figures/asia-1.png" width="50%" style="display: block; margin: auto;" /></p>
<p>This can be very useful for quickly checking the geographic correspondence between two or more layers: the <code>plot()</code> function is fast to execute and requires few lines of code, but does not create interactive maps with a wide range of options. For more advanced map making we recommend using a dedicated visualization package such as <strong>tmap</strong>, <strong>ggplot2</strong>, <strong>mapview</strong>, or <strong>leaflet</strong>. <!-- TODO: cross reference advanced mapping chapter --></p>
<!-- 
- plot() function 
- map export 
-->
<!-- Maybe show also somewhere that `world[0]` produces only a plot of the geometry which is rather useful if you do not want to plot a specific attribute. This way, you can for example dismiss the col = "white"-argument in your Nigeria example. -->
<div id="further-work" class="section level4">
<h4><span class="header-section-number">2.1.3.1</span> Further work</h4>
<p><strong>sf</strong> makes R data objects more closely aligned to the data model used in GDAL and GEOS, in theory making spatial data operations faster. The work here provides a taste of the way <strong>sf</strong> operates but there is much more to learn (see Chapter <a href="spatial-data-operations.html#spatial-data-operations">4</a>). And there is also a wealth of information in the highly recommended vignettes of the package.</p>
<p>As a final exercise, we’ll see one way of how to do a spatial overlay in <strong>sf</strong>. First, we convert the countries of the world into centroids, and then subset those in Asia. Finally, the <code>summary</code>-command tells us how many centroids (countries) are part of Asia (43) and how many are not (134).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_centroids =<span class="st"> </span><span class="kw">st_centroid</span>(world)
<span class="co">#&gt; Warning in st_centroid.sfc(st_geometry(x)): st_centroid does not give</span>
<span class="co">#&gt; correct centroids for longitude/latitude data</span>
sel_asia =<span class="st"> </span><span class="kw">st_intersects</span>(world_centroids, asia, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; although coordinates are longitude/latitude, it is assumed that they are planar</span>
<span class="kw">summary</span>(sel_asia)
<span class="co">#&gt;      V1         </span>
<span class="co">#&gt;  Mode :logical  </span>
<span class="co">#&gt;  FALSE:134      </span>
<span class="co">#&gt;  TRUE :43</span></code></pre></div>
<p>Note: another way of achieving the same result is with a GEOS function for identifying spatial overlay, which we’ll cover in more detail in Chapter <a href="spatial-data-operations.html#spatial-data-operations">4</a>.</p>
<p><strong>sf</strong>’s <code>plot()</code> function builds on base plotting methods, allowing access to its many optional arguments (see <code>?plot</code>). This provides powerful but not necessarily intuitive functionality, as illustrated by the variable circle sizes generated by the <code>cex</code> argument (see Figure <a href="spatial-class.html#fig:africa">2.5</a>, generated by the code below).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(world[<span class="st">&quot;continent&quot;</span>])
<span class="kw">plot</span>(world_centroids, <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">cex =</span> world$pop /<span class="st"> </span><span class="fl">1e8</span>, <span class="dt">lwd =</span> <span class="dv">3</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:africa"></span>
<img src="figures/africa-1.png" alt="Centroids representing country population, diameter being proportional to population." width="576" />
<p class="caption">
Figure 2.5: Centroids representing country population, diameter being proportional to population.
</p>
</div>
<!-- More appropriate for subsequent chapters. -->
<!-- This shows that there are 43 countries in Asia -->
<!-- We can check if they are the same countries as follows: -->
<!-- ```{r} -->
<!-- africa_centroids2 = world_centroids[sel_africa,] -->
<!-- identical(africa_centroids, africa_centroids2) -->
<!-- ``` -->
</div>
</div>
<div id="sf_classes" class="section level3">
<h3><span class="header-section-number">2.1.4</span> Simple feature classes</h3>
<p>To understand new data formats in depth, it often helps to generate them for first principles. This section walks through vector spatial classes step-by-step, from the elementary simple feature geometry to simple feature objects, with class <code>sf</code>, representing complex spatial data. Before describing each geometry type that the <strong>sf</strong> package supports it is worth taking a step back to understand the building blocks of <code>sf</code> objects. As stated in section <a href="spatial-class.html#intro-sf">2.1.1</a>, simple features are simply dataframes with at least one special column that makes it spatial. These spatial columns are often called <code>geom</code> or <code>geometry</code> and can be like non-spatial columns: <code>world$geom</code> refers to the spatial element of the <code>world</code> object described above. These geometry columns are ‘list columns’ of class <code>sfc</code>: they are simple feature collections. In turn, <code>sfc</code> objects are composed of one or more objects of class <code>sfg</code>: simple feature geometries.</p>
<p>To understand how the spatial components of simple features work, it is vital to understand simple feature geometries. For this reason we cover each type currently supported <code>sfg</code> in the next sections before moving to describe how they can be combined to form <code>sfc</code> and eventually full <code>sf</code> objects.</p>
<div id="geometry" class="section level4">
<h4><span class="header-section-number">2.1.4.1</span> Simple feature geometry types</h4>
<!-- This section demonstrates how the full range of geometry types supported by the **sf** package can be created, combined and plotted. -->
<p>Geometries are the basic building blocks of simple features. Simple features could be represented as one of the 17 geometry types using the <strong>sf</strong> package. In this chapter we will focus on seven, the most commonly used, simple features types: <code>POINT</code>, <code>LINESTRING</code>, <code>POLYGON</code>, <code>MULTIPOINT</code>, <code>MULTILINESTRING</code>, <code>MULTIPOLYGON</code> and <code>GEOMETRYCOLLECTION</code>.<!--FIG--> The whole list of possible feature types could be found in <a href="http://postgis.net/docs/using_postgis_dbmanagement.html">the PostGIS manual</a>.</p>
<p>Simple features, outside of an R environment, could be represented in one of two ways, ether as a well-known binary (WKB) or well-known text (WKT). Well-known binary (WKB) representations are usually hexadecimal strings, which are used to transfer and store geometry objects in databases. Well-known text (WKT), on the other hand, is a text markup description of simple features. Both formats are exchangeable, therefore we would focus only on the well-known text (WKT) representation.</p>
<p>All of the geometry types are built of points. Each point could be described as coordinates in a 2D, 3D or 4D space:</p>
<ul>
<li>X and Y coordinates represent location of points. It could be either easting and northing or longitude and latitude.</li>
<li>A Z coordinate denotes altitude.</li>
<li>An M coordinate (“measure”) allows to represent some measure associated to the point, but not the whole feature. This coordinate could be a time of measurement, information who measured this point or what’s the error of measurement.</li>
</ul>
<p>As a result, four possible types of points exist - XY (two-dimensional), XYZ (three-dimensional containing altitude), XYM (three-dimensional containing measure) and XYZM (four-dimensional). They could be easily describes as a well-known text:</p>
<ul>
<li>XY - <code>POINT (5 2)</code></li>
<li>XYZ - <code>POINT (5 2 3)</code></li>
<li>XYM - <code>POINTM (5 2 1)</code></li>
<li>XYZM - <code>POINT (5 2 3 1)</code></li>
</ul>
<p><img src="figures/point-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>A linestring is represented by a sequence of points with linear interpolation between points, for example:</p>
<ul>
<li><code>LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)</code></li>
</ul>
<p><img src="figures/linestring-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>Linestring cannot have self intersecting line part. In other words, lines shouldn’t pass through the same point twice (except for the endpoint).</p>
<p>A polygon is a sequence of points, where the first and last point have the same coordinates. Similarly to linestring, polygon needs to create a non-self intersecting ring. By the definition, polygon has one exterior boundary (outer ring) and zero or more interior boundaries (inner ring). These interior boundaries are often known as holes.</p>
<ul>
<li>Zero interior boundaries (holes) - <code>POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))</code></li>
</ul>
<p><img src="figures/polygon-1.png" width="576" style="display: block; margin: auto;" /></p>
<ul>
<li>One hole - <code>POLYGON ((1 5, 4 4, 4 1, 2 2, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))</code></li>
</ul>
<p><img src="figures/polygon_hole-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>The next three geometry types are the sets of previous ones: a multipoint is a set of points, multilinestring is a set strings and multipolygon is a set of polygons:</p>
<ul>
<li>Multipoint - <code>MULTIPOINT (5 2, 1 3, 3 4, 3 2)</code></li>
<li>Multistring - <code>MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))</code></li>
<li>Multipolygon - <code>MULTIPOLYGON ((1 5, 4 4, 4 1, 2 2, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2))</code></li>
</ul>
<p><img src="figures/multis-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>A geometry collection is the most heterogeneous type. It could consists of a set of any geometry types previously mentioned, for example:</p>
<ul>
<li>Geometry collection - <code>GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)))</code></li>
</ul>
<p><img src="figures/geom_collection-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<div id="sfg" class="section level4">
<h4><span class="header-section-number">2.1.4.2</span> Simple feature geometry (sfg) objects</h4>
<p>Simple feature geometry types are represented in R by objects of a <code>sfg</code> class. A <code>sfg</code> object is a geometry of a single feature - a point, linestring, polygon, multipoint, multilinestring, multipolygon or geometry collection.</p>
<p>Usually you don’t need to create geometries on your own. In most cases, geometries are read from spatial files. However, a set of function to create simple feature geometry objects (<code>sfg</code>) exists in R and could be used in special cases. The names of these functions are simple and consistent, as they start with a <code>st_</code> prefix and end with name of geometry types in lowercase letters:</p>
<ul>
<li>A point - <code>st_point()</code></li>
<li>A linestring - <code>st_linestring()</code></li>
<li>A polygon - <code>st_polygon()</code></li>
<li>A multipoint - <code>st_multipoint()</code></li>
<li>A multilinestring - <code>st_multilinestring()</code></li>
<li>A multipolygon - <code>st_multipolygon()</code></li>
<li>A geometry collection - <code>st_geometrycollection()</code></li>
</ul>
<p>In R, <code>sfg</code> objects are represented by three native data types:</p>
<ol style="list-style-type: decimal">
<li>A numeric vector - a single point</li>
<li>A matrix - a set of points, where each row contains a point - a multipoint or linestring</li>
<li>A list - any other set, e.g. a multilinestring or geometry collection</li>
</ol>
<p>To create point objects, we could use the <code>st_point()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note that we use a numeric vector for points</span>
<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>)) <span class="co"># XY point</span>
<span class="co">#&gt; POINT(5 2)</span>
<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">3</span>)) <span class="co"># XYZ point</span>
<span class="co">#&gt; POINTZ(5 2 3)</span>
<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">1</span>), <span class="dt">dim =</span> <span class="st">&quot;XYM&quot;</span>) <span class="co"># XYM point</span>
<span class="co">#&gt; POINTM(5 2 1)</span>
<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>)) <span class="co"># XYZM point</span>
<span class="co">#&gt; POINTZM(5 2 3 1)</span></code></pre></div>
<p>XY, XYZ and XYZM types of points are automatically created based on the length of a numeric vector. Only the XYM type needs to be specified using a <code>dim</code> argument.</p>
<p>Multipoint and linestring objects are created based on a matrix using <code>st_multipoint()</code> and <code>st_linestring()</code> functions:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># the rbind function simplify creation of matrices</span>
## MULTIPOINT
multipoint_matrix =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>))
<span class="kw">st_multipoint</span>(multipoint_matrix)
<span class="co">#&gt; MULTIPOINT(5 2, 1 3, 3 4, 3 2)</span>

## LINESTRING
linestring_matrix =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>))
<span class="kw">st_linestring</span>(linestring_matrix)
<span class="co">#&gt; LINESTRING(1 5, 4 4, 4 1, 2 2, 3 2)</span></code></pre></div>
<p>The rest of objects are represented by lists:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## POLYGON
polygon_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>)))
<span class="kw">st_polygon</span>(polygon_list)
<span class="co">#&gt; POLYGON((1 5, 2 2, 4 1, 4 4, 1 5))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## POLYGON with a hole
polygon_border =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>))
polygon_hole =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>))
polygon_with_hole_list =<span class="st"> </span><span class="kw">list</span>(polygon_border, polygon_hole)
<span class="kw">st_polygon</span>(polygon_with_hole_list)
<span class="co">#&gt; POLYGON((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## MULTILINESTRING
multilinestring_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)), 
                            <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>)))
<span class="kw">st_multilinestring</span>((multilinestring_list))
<span class="co">#&gt; MULTILINESTRING((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## MULTIPOLYGON
multipolygon_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>))),
                         <span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>))))
<span class="kw">st_multipolygon</span>(multipolygon_list)
<span class="co">#&gt; MULTIPOLYGON(((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## GEMETRYCOLLECTION
gemetrycollection_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">st_multipoint</span>(multipoint_matrix),
                              <span class="kw">st_linestring</span>(linestring_matrix))
<span class="kw">st_geometrycollection</span>(gemetrycollection_list)
<span class="co">#&gt; GEOMETRYCOLLECTION(MULTIPOINT(5 2, 1 3, 3 4, 3 2), LINESTRING(1 5, 4 4, 4 1, 2 2, 3 2))</span></code></pre></div>
<!-- table -->
<!-- figure - image/fig1.jpg -->
<!-- they are interconnected - points could create mulitpoints or lines; -->
<!-- lines could create mutlilines or polygons, etc. -->
<!-- https://r-spatial.github.io/sf/articles/sf1.html -->
</div>
<div id="sfc" class="section level4">
<h4><span class="header-section-number">2.1.4.3</span> Simple feature collections</h4>
<p>One <code>sfg</code> object contains only a single simple feature geometry. A simple feature collection (<code>sfc</code>) is a list of <code>sfg</code> objects with information about a coordinate reference system. The <code>st_sfc()</code> function can be used to create <code>sfc</code> objects, as illustrated in the code below, which combines two simple features of a point type into a single feature:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfc POINT</span>
point1 =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>))
point2 =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">st_sfc</span>(point1, point2)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT(5 2)</span>
<span class="co">#&gt; POINT(1 3)</span></code></pre></div>
<p>In most cases, an <code>sfc</code> object contains objects of identical geometry type. Therefore, when we combine <code>sfg</code> objects of a polygon type we would get <code>sfc</code> of a polygon type, and a collection of multilinestring would result into <code>sfc</code> of a multilinestring type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfc POLYGON</span>
polygon_list1 =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>)))
polygon1 =<span class="st"> </span><span class="kw">st_polygon</span>(polygon_list)
polygon_list2 =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>)))
polygon2 =<span class="st"> </span><span class="kw">st_polygon</span>(polygon_list2)
<span class="kw">st_sfc</span>(polygon1, polygon2)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 1 xmax: 4 ymax: 5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POLYGON((1 5, 2 2, 4 1, 4 4, 1 5))</span>
<span class="co">#&gt; POLYGON((0 2, 1 2, 1 3, 0 3, 0 2))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfc MULTILINESTRING</span>
multilinestring_list1 =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)), 
                            <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>)))
multilinestring1 =<span class="st"> </span><span class="kw">st_multilinestring</span>((multilinestring_list1))
multilinestring_list2 =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">9</span>), <span class="kw">c</span>(<span class="dv">7</span>, <span class="dv">9</span>), <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">6</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">7</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">7</span>)), 
                            <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">7</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">8</span>)))
multilinestring2 =<span class="st"> </span><span class="kw">st_multilinestring</span>((multilinestring_list2))
<span class="kw">st_sfc</span>(multilinestring1, multilinestring2)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  MULTILINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 1 xmax: 7 ymax: 9</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; MULTILINESTRING((1 5, 4 4, 4 1, 2 2, 3 2), (1 2...</span>
<span class="co">#&gt; MULTILINESTRING((2 9, 7 9, 5 6, 4 7, 2 7), (1 7...</span></code></pre></div>
<p>It is possible to create a <code>sfc</code> object from <code>sfg</code> objects with different geometry types. This new object would have a “geometry” geometry type:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfc GEOMETRY</span>
<span class="kw">st_sfc</span>(point1, multilinestring1)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  GEOMETRY</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 1 xmax: 5 ymax: 5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT(5 2)</span>
<span class="co">#&gt; MULTILINESTRING((1 5, 4 4, 4 1, 2 2, 3 2), (1 2...</span></code></pre></div>
<!-- if you want to use it - st_cast() to a proper geometry type -->
<!-- or st_is to select only one geometry type -->
<!-- http://r-spatial.org/r/2017/01/12/newssf.html -->
<!-- methods(class = "sfc") -->
<p>The simple feature collection objects could have more information about spatial data than just geometries. It is possible to store coordinate reference systems (CRS) in them. <!-- What's CRS --> CRS can be represented by <code>epsg (SRID)</code> and <code>proj4string</code> attributes. The default value of <code>epsg (SRID)</code> and <code>proj4string</code> is <code>NA</code> (<em>Not Available</em>), which is used when the CRS is unknown:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_sfc</span>(point1, point2)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT(5 2)</span>
<span class="co">#&gt; POINT(1 3)</span></code></pre></div>
<p>The <code>sfc</code> object could have <code>NA</code> values in both attributes or have an actual value for one or two CRS attributes. Importantly, all geometries in the <code>sfc</code> objects must have the same CRS.</p>
<p>We can add coordinate reference system as a <code>crs</code> argument of <code>st_sfc()</code>. This argument could accept either an integer with the <code>epsg</code> code or character with <code>proj4string</code>.</p>
<p>For example, we can set the WGS 84 using either its epsg code (<code>4326</code>) or its <code>proj4string</code> definition (<code>&quot;+proj=longlat +datum=WGS84 +no_defs&quot;</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># EPSG definition</span>
<span class="kw">st_sfc</span>(point1, point2, <span class="dt">crs =</span> <span class="dv">4326</span>)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt; POINT(5 2)</span>
<span class="co">#&gt; POINT(1 3)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># PROJ4STRING definition</span>
<span class="kw">st_sfc</span>(point1, point2, <span class="dt">crs =</span> <span class="st">&quot;+proj=longlat +datum=WGS84 +no_defs&quot;</span>)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt; POINT(5 2)</span>
<span class="co">#&gt; POINT(1 3)</span></code></pre></div>
<p>Both of these approaches have advantages and disadvantages. An <code>epsg</code> code is usually shorter and therefore easier to remember. The code also refers to only one, well-defined coordinate reference system. It could be, however, considered a limitation of <code>epsg</code>, as it is not flexible. On the hand, a <code>proj4string</code> definition is longer - it could specify many different parameters, such as projection type, datum and ellipsoid. This makes <code>proj4string</code> more complicated, but also allows to create many different projections and modify existing ones. <code>proj4string</code> is also supported by the PROJ.4 software (and therefore by the <code>sf</code> package), which enables transformations between different projections.</p>
<p><code>epsg</code> always points to a particular CRS. This property makes possible for PROJ.4 to convert <code>epsg</code> into corresponding <code>proj4string</code>. For example, we can set the UTM Zone 11N projection with <code>epsg</code> code <code>2955</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_sfc</span>(point1, point2, <span class="dt">crs =</span> <span class="dv">2955</span>)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    2955</span>
<span class="co">#&gt; proj4string:    +proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs</span>
<span class="co">#&gt; POINT(5 2)</span>
<span class="co">#&gt; POINT(1 3)</span></code></pre></div>
<p>As you can see above, the <code>proj4string</code> definition was automatically added. Now we can try to set the CRS using <code>proj4string</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_sfc</span>(point1, point2, <span class="dt">crs =</span> <span class="st">&quot;+proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;</span>)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    +proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs</span>
<span class="co">#&gt; POINT(5 2)</span>
<span class="co">#&gt; POINT(1 3)</span></code></pre></div>
<p>The above result doesn’t contain <code>epsg</code>. This is due the fact that no general method for conversion from <code>proj4string</code> to <code>epsg</code> exists.</p>
<!-- precision -->
<!-- plots can be made -->
</div>
<div id="sf" class="section level4">
<h4><span class="header-section-number">2.1.4.4</span> Simple feature objects</h4>
<p>Most of the time, geometries are related to a set of attributes. These attributes could represent the name of the geometry, measured value, group to which the geometry belongs, and many more. For example, we measured a temperature of 25°C on the Trafalgar Square in London on June 21<sup>th</sup> 2017. This can be described not only by its coordinates and temperature value, but also by the name of the point, the date of the measurement, it’s category (city or village), or if the measurement was made using an automatic station.</p>
<p>The simple feature class, <code>sf</code>, is a combination of an attribute table (<code>data.frame</code>) and simple feature geometry collection (<code>sfc</code>). Simple features are created using the <code>st_sf()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfg objects</span>
london_point =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">51.5</span>))
ruan_point =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(-<span class="dv">9</span>, <span class="dv">53</span>))

<span class="co"># sfc object</span>
our_geometry =<span class="st"> </span><span class="kw">st_sfc</span>(london_point, ruan_point, <span class="dt">crs =</span> <span class="dv">4326</span>)

<span class="co"># data.frame object</span>
our_attributes =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">name =</span> <span class="kw">c</span>(<span class="st">&quot;London&quot;</span>, <span class="st">&quot;Ruan&quot;</span>),
                            <span class="dt">temperature =</span> <span class="kw">c</span>(<span class="dv">25</span>, <span class="dv">13</span>),
                            <span class="dt">date =</span> <span class="kw">c</span>(<span class="kw">as.Date</span>(<span class="st">&quot;2017-06-21&quot;</span>), <span class="kw">as.Date</span>(<span class="st">&quot;2017-06-22&quot;</span>)),
                            <span class="dt">category =</span> <span class="kw">c</span>(<span class="st">&quot;city&quot;</span>, <span class="st">&quot;village&quot;</span>),
                            <span class="dt">automatic =</span> <span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">TRUE</span>))

<span class="co"># sf object</span>
sf_points =<span class="st"> </span><span class="kw">st_sf</span>(our_attributes, <span class="dt">geometry =</span> our_geometry)</code></pre></div>
<p>The above example illustrates the components of <code>sf</code> objects. Firstly, simple feature geometry (<code>sfg</code>) objects are defined using coordinates. These objects are combined into a simple feature collection (<code>sfc</code>). The <code>sfc</code> also stores the information about coordinate reference system. <code>data.frame</code> is created, where each row corresponds to one geometry feature. Finally, the attribute table and <code>sfc</code> object are tied together using the <code>st_sf()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sf_points
<span class="co">#&gt; Simple feature collection with 2 features and 5 fields</span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -9 ymin: 51.5 xmax: 0.1 ymax: 53</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt;     name temperature       date category automatic        geometry</span>
<span class="co">#&gt; 1 London          25 2017-06-21     city     FALSE POINT(0.1 51.5)</span>
<span class="co">#&gt; 2   Ruan          13 2017-06-22  village      TRUE    POINT(-9 53)</span></code></pre></div>
<p>The resulting object has two classes - <code>sf</code> and <code>data.frame</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(sf_points)
<span class="co">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></code></pre></div>
<p>The result shows that <code>sf</code> objects actually have two classes, <code>sf</code> and <code>data.frame</code>. Simple features are simply data frames (square tables), but with spatial attributes (usually stored in a special <code>geom</code> list-column in the data frame). This duality is central to the concept of simple features: most of the time a <code>sf</code> can be treated as and behaves like a <code>data.frame</code>. Simple features are, in essence, data frames with a spatial extension.</p>
<!-- methods -->
<!-- methods(class = "sf") -->
<!-- plots -->
<!-- https://r-spatial.github.io/sf/articles/sf1.html#how-attributes-relate-to-geometries -->
</div>
</div>
</div>
<div id="raster-data" class="section level2">
<h2><span class="header-section-number">2.2</span> Raster data</h2>
<p>Raster data is a matrix (or a grid) of values with additional spatial metadata, such as extent, resolution and coordinate reference system. This grid consists of cells (often called pixels) representing an area on the surface (<a href="spatial-class.html#fig:raster-intro-plot">2.6</a>:A). All cells in a raster must have the same size, which could be represented by a Cartesian (e.g. meters) or geographic coordinate system (degrees). Cell numbers in rasters start at 1 in the upper left corner, and its number increase from left to right and then from top to bottom (<a href="spatial-class.html#fig:raster-intro-plot">2.6</a>:B). Each cell in raster data could hold a value, which could be an integer or float (<a href="spatial-class.html#fig:raster-intro-plot">2.6</a>:C). Additionally, it is possible to set the NA (<em>not available</em>) value which indicates the absence of data or cells outside of the area of interests. You can see them as the gray cells in the C and D panel of the figure <a href="spatial-class.html#fig:raster-intro-plot">2.6</a>. The final raster map, as seen in the D panel of the <a href="spatial-class.html#fig:raster-intro-plot">2.6</a> figure, is a color presentation of the raster values.</p>
<div class="figure" style="text-align: center"><span id="fig:raster-intro-plot"></span>
<img src="figures/raster_intro_plot.png" alt="Raster data: A - a grid representation; B - numbers of the cells; C - values of the cells; D - a final raster map" width="750" />
<p class="caption">
Figure 2.6: Raster data: A - a grid representation; B - numbers of the cells; C - values of the cells; D - a final raster map
</p>
</div>
<p>Raster data can be continuous or categorical <a href="spatial-class.html#fig:raster-intro-plot2">2.7</a>. Continuous rasters have a range of quantitative values, which could represent phenomena such as elevation, temperature, population density or spectral data. Categorical rasters, also known as discrete, represent features or categories. This could be landcover, soils, or climate categories data.</p>
<div class="figure" style="text-align: center"><span id="fig:raster-intro-plot2"></span>
<img src="figures/raster_intro_plot2.png" alt="Exampled of continuous (left) and categorical (right) raster" width="475" />
<p class="caption">
Figure 2.7: Exampled of continuous (left) and categorical (right) raster
</p>
</div>
<div id="an-introduction-to-raster" class="section level3">
<h3><span class="header-section-number">2.2.1</span> An introduction to raster</h3>
<p>Raster objects in R are supported by the <strong>raster</strong> package. It provides an extensive set of functions to create, read, processed and write of raster datasets. Beside the general raster data manipulation, <strong>raster</strong> provides many low level functions that can be used to create and develop new concepts. <strong>raster</strong> also supports work on large raster datasets that are stored on a hard drive, but are too large to fit into memory. Instead of recreating the whole file in RAM, this package extracts information about the structure of the dataset, such as a number of rows and columns, spatial extent and the name of the file. When manipulating this dataset, values are read and processed in a small chunk and written either to a specified file on a disk or temporary file.</p>
<p>The <strong>raster</strong> package provides three main classes of objects - <code>RasterLayer</code>, <code>RasterBrick</code> and <code>RasterStack</code>. We would refer to all of them as <code>Raster*</code>.</p>
<p>For the illustration of the <strong>raster</strong> concepts, we will use datasets from the <strong>spDataLarge</strong> package. It consists of a few raster and one vector datasets representing an area of Zion National Park. For example, <code>srtm.tif</code> is a digital elevation model of this area. <!-- for more details - see the documentation ADD DOCS --> Firstly, we would create a new <code>RasterLayer</code> object <code>new_raster</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spDataLarge)
<span class="kw">library</span>(raster)
raster_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/srtm.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>)
new_raster =<span class="st"> </span><span class="kw">raster</span>(raster_filepath)</code></pre></div>
<p>The <code>Raster*</code> objects store three types of information: spatial, non-spatial and metadata. All of them could be shown by just typing the name of the object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">new_raster
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 463, 459, 212517  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 73.7, 92.5  (x, y)</span>
<span class="co">#&gt; extent      : 301929, 335757, 4111262, 4154089  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs </span>
<span class="co">#&gt; data source : /home/travis/R/Library/spDataLarge/raster/srtm.tif </span>
<span class="co">#&gt; names       : srtm </span>
<span class="co">#&gt; values      : 1050, 2895  (min, max)</span></code></pre></div>
<p>Raster’s spatial properties are expressed as the dimensions (number of rows, number of columns, number of cells and number of layers for multilayer objects), resolution, extent and coordinate reference system of the data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># dimensions (number of rows, number of columns, number of cells)</span>
<span class="kw">dim</span>(new_raster)
<span class="co">#&gt; [1] 463 459   1</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># spatial resolution</span>
<span class="kw">res</span>(new_raster)
<span class="co">#&gt; [1] 73.7 92.5</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># spatial extent</span>
<span class="kw">extent</span>(new_raster)
<span class="co">#&gt; class       : Extent </span>
<span class="co">#&gt; xmin        : 301929 </span>
<span class="co">#&gt; xmax        : 335757 </span>
<span class="co">#&gt; ymin        : 4111262 </span>
<span class="co">#&gt; ymax        : 4154089</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># coordinate reference system</span>
<span class="kw">crs</span>(new_raster)
<span class="co">#&gt; CRS arguments:</span>
<span class="co">#&gt;  +proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m</span>
<span class="co">#&gt; +no_defs</span></code></pre></div>
<p>Unlike the <strong>sf</strong> package, <strong>raster</strong> only use the <code>proj4string</code> representation of the coordinate reference system.</p>
<p>Values of the cells are the only non-spatial information in the <code>Raster*</code> object. They could be summarized and plotted using the base R functions, such as <code>summary()</code> and <code>hist()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># numerical summary of the data</span>
<span class="kw">summary</span>(new_raster)
<span class="co">#&gt; Warning in .local(object, ...): summary is an estimate based on a sample of 1e+05 cells (47.06% of all cells)</span>
<span class="co">#&gt;         srtm</span>
<span class="co">#&gt; Min.    1050</span>
<span class="co">#&gt; 1st Qu. 1544</span>
<span class="co">#&gt; Median  1840</span>
<span class="co">#&gt; 3rd Qu. 2121</span>
<span class="co">#&gt; Max.    2895</span>
<span class="co">#&gt; NA&#39;s       0</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># histogram of the values</span>
<span class="kw">hist</span>(new_raster)
<span class="co">#&gt; Warning in .hist1(x, maxpixels = maxpixels, main = main, plot = plot, ...):</span>
<span class="co">#&gt; 47% of the raster cells were used. 100000 values used.</span></code></pre></div>
<p><img src="figures/new_raster-hist-1.png" width="576" style="display: block; margin: auto;" /></p>
<p><code>getValues()</code> can be used to extract the values as a numerical vector.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">new_raster_values =<span class="st"> </span><span class="kw">getValues</span>(new_raster)
<span class="kw">head</span>(new_raster_values)
<span class="co">#&gt; [1] 1743 1739 1730 1721 1715 1709</span></code></pre></div>
<p>The new vector, <code>new_raster_values</code>, could be an input for many statistical operations.</p>
<p>Metadata in <code>Raster*</code> include, for example a class of the object, path to the source of the data and names of the layers.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># class of the object</span>
<span class="kw">class</span>(new_raster)
<span class="co">#&gt; [1] &quot;RasterLayer&quot;</span>
<span class="co">#&gt; attr(,&quot;package&quot;)</span>
<span class="co">#&gt; [1] &quot;raster&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># file path to the data source</span>
<span class="kw">filename</span>(new_raster)
<span class="co">#&gt; [1] &quot;/home/travis/R/Library/spDataLarge/raster/srtm.tif&quot;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># names of layer in the `Raster*` object</span>
<span class="kw">names</span>(new_raster)
<span class="co">#&gt; [1] &quot;srtm&quot;</span></code></pre></div>
<p>Sometimes it could be important to know if the values of the files are in RAM or on disk using the <code>inMemory()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">inMemory</span>(new_raster)
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
<p>The full list of the <strong>raster</strong> function could be found using <code>help(package = &quot;raster&quot;, topic = &quot;raster-package&quot;)</code>.</p>
</div>
<div id="basic-map-making" class="section level3">
<h3><span class="header-section-number">2.2.2</span> Basic map making</h3>
<p>Just as in the <strong>sf</strong> package, basic raster maps can be created with the <code>plot()</code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(new_raster)</code></pre></div>
<p><img src="figures/basic-new-raster-plot-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>Moreover, it is possible to plot raster together with vector data. For this purpose, we need to read a vector dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vector_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;vector/zion.gpkg&quot;</span>, <span class="dt">package=</span><span class="st">&quot;spDataLarge&quot;</span>)
new_vector =<span class="st"> </span><span class="kw">st_read</span>(vector_filepath)
<span class="co">#&gt; Reading layer `zion&#39; from data source `/home/travis/R/Library/spDataLarge/vector/zion.gpkg&#39; using driver `GPKG&#39;</span>
<span class="co">#&gt; Simple feature collection with 1 feature and 11 fields</span>
<span class="co">#&gt; geometry type:  POLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 302903.1 ymin: 4112244 xmax: 334735.5 ymax: 4153087</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    +proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs</span></code></pre></div>
<p>Our new object, <code>new_vector</code>, is a polygon representing borders of Zion National Park. We could impose these borders on a elevation map with the second use of the <code>plot()</code> function, this time with the <code>add</code> argument set to <code>TRUE</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(new_raster)
<span class="kw">plot</span>(new_vector, <span class="dt">add =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="figures/basic-new-raster-vector-plot-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>There are several different approaches to plot raster data in R. The <strong>rasterVis</strong> package provides a set of methods for visualization of univariate and multivariate (such as spatiotemporal) rasters. Moreover, packages such as <strong>tmap</strong>, <strong>mapview</strong> and <strong>leaflet</strong> facilitate presentation of both, raster and vector, objects. <!-- TODO: cross reference advanced mapping chapter --></p>
</div>
<div id="raster-classes" class="section level3">
<h3><span class="header-section-number">2.2.3</span> Raster classes</h3>
<p><code>RasterLayer</code> represents the simplest raster object, consisting of only one layer and store information about a number of rows and columns, spatial object extent and coordinate reference system used. <!-- CRS as proj4 --> This raster class could store raster values in a RAM memory or only point to a file on hard drive that holds the values.</p>
<p>Object of the <code>RasterLayer</code> class is created by the <code>raster()</code> function: <!-- explanation that this function can do many more things --> <!-- how to add crs --> <!-- how to add values --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r =<span class="st"> </span><span class="kw">raster</span>() <span class="co"># creation of an empty RasterLayer object</span>
r
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 180, 360, 64800  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 1, 1  (x, y)</span>
<span class="co">#&gt; extent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># creation of the RasterLayer object with a given number of columns and rows, and extent</span>
r1 =<span class="st"> </span><span class="kw">raster</span>(<span class="dt">ncol =</span> <span class="dv">101</span>, <span class="dt">nrow =</span> <span class="dv">77</span>, <span class="dt">xmn =</span> <span class="dv">0</span>, <span class="dt">xmx =</span> <span class="dv">101</span>, <span class="dt">ymn =</span> <span class="dv">0</span>, <span class="dt">ymx =</span> <span class="dv">77</span>)
r1
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 77, 101, 7777  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 1, 1  (x, y)</span>
<span class="co">#&gt; extent      : 0, 101, 0, 77  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0</span>
<span class="kw">values</span>(r1) =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:<span class="kw">ncell</span>(r1)) <span class="co"># adding random values to the new raster object</span></code></pre></div>
<p>Two additional classes, <code>RasterBrick</code> and <code>RasterStack</code> are used when dealing with multiple layers. These two classes differ in terms of a number of supported files, type of representation and processing speed.</p>
<p>A <code>RasterBrick</code> contain multiple layers of raster data, which refer to only a single, mutlilayer file, such as multispectral satellite image. <code>RasterBrick</code> objects are created using the <code>brick()</code> function. This function usually takes a filename to a multilayer raster file. However, it is also possible to provide a <code>Raster*</code> object, <code>array</code> and a few more. All of possible formats could be found on the help file of this function - <code>?brick</code>. <!-- should we use this example or have our own multilayer dataset? --></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multilayer_raster_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/landsat.tif&quot;</span>, <span class="dt">package=</span><span class="st">&quot;spDataLarge&quot;</span>)
r_brick =<span class="st"> </span><span class="kw">brick</span>(multilayer_raster_filepath)
r_brick
<span class="co">#&gt; class       : RasterBrick </span>
<span class="co">#&gt; dimensions  : 1428, 1128, 1610784, 4  (nrow, ncol, ncell, nlayers)</span>
<span class="co">#&gt; resolution  : 30, 30  (x, y)</span>
<span class="co">#&gt; extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 </span>
<span class="co">#&gt; data source : /home/travis/R/Library/spDataLarge/raster/landsat.tif </span>
<span class="co">#&gt; names       : landsat.1, landsat.2, landsat.3, landsat.4 </span>
<span class="co">#&gt; min values  :      7550,      6404,      5678,      5252 </span>
<span class="co">#&gt; max values  :     19071,     22051,     25780,     31961</span></code></pre></div>
<p>The <code>nlayers</code> function helps to get the number of layers in a <code>Raster*</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nlayers</span>(r_brick)
<span class="co">#&gt; [1] 4</span></code></pre></div>
<p>A <code>RasterStack</code> is a list of <code>RasterLayer</code> objects with the same extent and resolution. These layers could contain the same variable over some time or many different variables. <code>RasterStack</code> can be created based on a group of object from many sources - different files, another bands in a multi-band file and <code>RasterLayer</code> objects created in R.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">raster_on_disk =<span class="st"> </span><span class="kw">raster</span>(r_brick, <span class="dt">layer =</span> <span class="dv">1</span>)
raster_in_memory =<span class="st"> </span><span class="kw">raster</span>(<span class="dt">xmn =</span> <span class="dv">301905</span>, <span class="dt">xmx =</span> <span class="dv">335745</span>, <span class="dt">ymn =</span> <span class="dv">4111245</span>, <span class="dt">ymx =</span> <span class="dv">4154085</span>, <span class="dt">res =</span> <span class="dv">30</span>)
<span class="kw">values</span>(raster_in_memory) =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:<span class="kw">ncell</span>(raster_in_memory))
<span class="kw">crs</span>(raster_in_memory) =<span class="st"> </span><span class="kw">crs</span>(raster_on_disk)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r_stack &lt;-<span class="st"> </span><span class="kw">stack</span>(raster_in_memory, raster_on_disk)
r_stack
<span class="co">#&gt; class       : RasterStack </span>
<span class="co">#&gt; dimensions  : 1428, 1128, 1610784, 2  (nrow, ncol, ncell, nlayers)</span>
<span class="co">#&gt; resolution  : 30, 30  (x, y)</span>
<span class="co">#&gt; extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 </span>
<span class="co">#&gt; names       :   layer, landsat.1 </span>
<span class="co">#&gt; min values  :       1,      7550 </span>
<span class="co">#&gt; max values  : 1610784,     19071</span></code></pre></div>
<p>Due to its properties, <code>RasterBrick</code> objects should be processed in a shorter time than <code>RasterStack</code>. Additionally, operations on <code>RasterBrick</code> and <code>RasterStack</code> objects will typically return <code>RasterBrick</code>. On the other hand, <code>RasterStack</code> give more flexibility, as a single object could be related to data stored in a memory and on disk in the same time. <code>RasterBrick</code> objects could be stored only in a memory or on disk.</p>
</div>
</div>
<div id="coordinate-reference-systems" class="section level2">
<h2><span class="header-section-number">2.3</span> Coordinate Reference Systems</h2>
<p>This section is work in progress.</p>
<p>Despite the differences between vector and raster spatial data types, they are united by shared concepts intrinsic to spatial data. Perhaps the most important of these is Coordinate Reference System (CRS), which defines how the spatial elements of the data relate to the surface of the Earth (or other body).</p>
<p>In <strong>sf</strong> the CRS of an object can be retrieved and set using <code>st_crs()</code> and <code>st_set_crs()</code> respectively:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">old_crs =<span class="st"> </span><span class="kw">st_crs</span>(sf_points) <span class="co"># get CRS</span>
old_crs <span class="co"># print CRS</span>
<span class="co">#&gt; $epsg</span>
<span class="co">#&gt; [1] 4326</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $proj4string</span>
<span class="co">#&gt; [1] &quot;+proj=longlat +datum=WGS84 +no_defs&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;crs&quot;</span>
sf_points =<span class="st"> </span><span class="kw">st_set_crs</span>(sf_points, <span class="dv">27700</span>) <span class="co"># set CRS</span>
<span class="co">#&gt; Warning: st_crs&lt;- : replacing crs does not reproject data; use st_transform</span>
<span class="co">#&gt; for that</span></code></pre></div>
<p>Note the warning emitted after the CRS for <code>sf_points</code> was set to <code>27700</code>. This is a good thing: we have imposed a spatial reference onto data without knowing what that means. To discover what the ‘magic number’ <code>27700</code> means, we can retrieve the CRS again (see Chapter <a href="#coord"><strong>??</strong></a> for more on CRSs):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_crs</span>(sf_points)
<span class="co">#&gt; $epsg</span>
<span class="co">#&gt; [1] 27700</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $proj4string</span>
<span class="co">#&gt; [1] &quot;+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;crs&quot;</span></code></pre></div>
</div>
<div id="units" class="section level2">
<h2><span class="header-section-number">2.4</span> Units</h2>
<!-- https://cran.r-project.org/web/packages/units/vignettes/measurement_units_in_R.html -->
<p>The final thing to say about <code>sf</code> objects in this chapter is that they have units. This is advantageous because it prevents confusion caused by the fact that different CRSs use different units (most use meters, some use feet). Furthermore, it also provides information on dimensionality, as illustrated by calculating the area of Nigeria:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nigeria =<span class="st"> </span>world[world$name_long ==<span class="st"> &quot;Nigeria&quot;</span>, ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_area</span>(nigeria)
<span class="co">#&gt; 9.05e+11 m^2</span></code></pre></div>
<p>The result, as expected, is in units of square meters (m<sup>2</sup>), representing 2 dimensional space, and that Nigeria is a large country! To translate the huge number into a more digestible size, it is tempting to divide the results by a million (the number of square meters in a square kilometer):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_area</span>(nigeria) /<span class="st"> </span><span class="fl">1e6</span>
<span class="co">#&gt; 905072 m^2</span></code></pre></div>
<p>However, the result is incorrectly given in the same units. The solution is to set the units with the <strong>units</strong> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">units::<span class="kw">set_units</span>(<span class="kw">st_area</span>(nigeria), km^<span class="dv">2</span>)
<span class="co">#&gt; 905072 km^2</span></code></pre></div>
<!-- Something about when units are not set: -->
<!-- ```{r} -->
<!-- st_distance(sf_point1, sf_point2) -->
<!-- ``` -->
<!-- ## Precision -->
</div>
<div id="exercises-1" class="section level2">
<h2><span class="header-section-number">2.5</span> Exercises</h2>
<ol style="list-style-type: decimal">
<li>What does the summary of the <code>geometry</code> column tell us about the <code>world</code> dataset, in terms of:</li>
</ol>
<ul>
<li>The geometry type?</li>
<li>How many countries there are?</li>
<li>The coordinate reference system (CRS)?</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Using <strong>sf</strong>’s <code>plot()</code> command, create a map of Nigeria in context, building on the code that creates and plots Asia above (see Figure <a href="#fig:nigeria"><strong>??</strong></a> for an example of what this could look like).</li>
</ol>
<ul>
<li>Hint: this used the <code>lwd</code>, <code>main</code> and <code>col</code> arguments of <code>plot()</code>.</li>
<li>Bonus: make the country boundaries a dotted grey line.</li>
<li>Hint: <code>border</code> is an additional argument of <code>plot()</code> for <strong>sf</strong> objects.</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Exercise 3 <!--missing title--></li>
</ol>
<ul>
<li>What does the <code>lwd</code> argument do in the <code>plot()</code> code that generates Figure <a href="spatial-class.html#fig:africa">2.5</a>.</li>
<li>Perform the same operations and map making for another continent of your choice.</li>
<li>Bonus: Download some global geographic data and add attribute variables assigning them to the continents of the world.</li>
</ul>

</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-gillespie_efficient_2016">
<p>Gillespie, Colin, and Robin Lovelace. 2016. <em>Efficient R Programming: A Practical Guide to Smarter Programming</em>. O’Reilly Media. <a href="https://csgillespie.github.io/efficientR/" class="uri">https://csgillespie.github.io/efficientR/</a>.</p>
</div>
<div id="ref-grolemund_r_2016">
<p>Grolemund, Garrett, and Hadley Wickham. 2016. <em>R for Data Science</em>. 1 edition. O’Reilly Media.</p>
</div>
<div id="ref-R-sf">
<p>Pebesma, Edzer. 2017. <em>Sf: Simple Features for R</em>. <a href="https://github.com/r-spatial/sf/" class="uri">https://github.com/r-spatial/sf/</a>.</p>
</div>
<div id="ref-R-sp">
<p>Pebesma, Edzer, and Roger Bivand. 2017. <em>Sp: Classes and Methods for Spatial Data</em>. <a href="https://CRAN.R-project.org/package=sp" class="uri">https://CRAN.R-project.org/package=sp</a>.</p>
</div>
<div id="ref-R-rgdal">
<p>Bivand, Roger, Tim Keitt, and Barry Rowlingson. 2017. <em>Rgdal: Bindings for the Geospatial Data Abstraction Library</em>. <a href="https://CRAN.R-project.org/package=rgdal" class="uri">https://CRAN.R-project.org/package=rgdal</a>.</p>
</div>
<div id="ref-R-rgeos">
<p>Bivand, Roger, and Colin Rundel. 2017. <em>Rgeos: Interface to Geometry Engine - Open Source (GEOS)</em>. <a href="https://CRAN.R-project.org/package=rgeos" class="uri">https://CRAN.R-project.org/package=rgeos</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="12">
<li id="fn12"><p>In 3 dimensional coordinate systems three numbers are needed for each of the three axes, <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span>.<a href="spatial-class.html#fnref12">↩</a></p></li>
<li id="fn13"><p>Other methods for generating numbers include with the <code>seq()</code> function (short for ‘sequence’) for generating regular sequences or <code>runif()</code>, <code>rnorm()</code> and other functions generating random numbers following some kind of probability distribution. The <strong>mapedit</strong> package can be used to create spatial data manually on an interactive map.<a href="spatial-class.html#fnref13">↩</a></p></li>
<li id="fn14"><p>The full OGC standard includes rather exotic geometry types including ‘surface’ and ‘curve’ geometry types, which currently have limited application in real world applications. All 68 types can be represented in R, although (at the time of writing) all methods, such as plotting, are only supported for the 7 types that are used.<a href="spatial-class.html#fnref14">↩</a></p></li>
<li id="fn15"><p>The development version, which may contain new features, can be installed with <code>devtools::install_github(&quot;r-spatial/sf&quot;).</code><a href="spatial-class.html#fnref15">↩</a></p></li>
<li id="fn16"><p>In fact, when you <code>plot()</code> an <strong>sf</strong> object, R is calling <code>sf:::plot.sf()</code> behind the scenes. <code>plot()</code> is a generic method that behaves differently depending on the class of object being plotted.<a href="spatial-class.html#fnref16">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="intro.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="attr.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Robinlovelace/geocompr/edit/master/02-spatial-data.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
