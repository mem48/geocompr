<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Geocomputation with R</title>
  <meta name="description" content="Forthcoming book on geographical data with R.">
  <meta name="generator" content="bookdown 0.5 and GitBook 2.6.7">

  <meta property="og:title" content="Geocomputation with R" />
  <meta property="og:type" content="book" />
  <meta property="og:url" content="http://robinlovelace.net/geocompr" />
  
  <meta property="og:description" content="Forthcoming book on geographical data with R." />
  <meta name="github-repo" content="Robinlovelace/geocompr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Geocomputation with R" />
  
  <meta name="twitter:description" content="Forthcoming book on geographical data with R." />
  

<meta name="author" content="Robin Lovelace, Jakub Nowosad, Jannes Muenchow">


<meta name="date" content="2017-09-08">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="intro.html">
<link rel="next" href="attr.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-0.9/htmlwidgets.js"></script>
<link href="libs/leaflet-0.7.7/leaflet.css" rel="stylesheet" />
<script src="libs/leaflet-0.7.7/leaflet.js"></script>
<link href="libs/leafletfix-1.0.0/leafletfix.css" rel="stylesheet" />
<link href="libs/leaflet-label-0.2.2/leaflet.label.css" rel="stylesheet" />
<script src="libs/leaflet-label-0.2.2/leaflet.label.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4-compressed.js"></script>
<script src="libs/Proj4Leaflet-0.7.2/proj4leaflet.js"></script>
<script src="libs/leaflet-binding-1.1.0/leaflet.js"></script>
<script src="libs/leaflet-providers-1.0.27/leaflet-providers.js"></script>
<script src="libs/leaflet-providers-plugin-1.1.0/leaflet-providers-plugin.js"></script>
<link href="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.css" rel="stylesheet" />
<script src="libs/leaflet-awesomemarkers-2.0.3/leaflet.awesome-markers.min.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-99618359-1', 'auto');
  ga('send', 'pageview');

</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

<link rel="stylesheet" href="css/style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Geocomputation with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Welcome</a><ul>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#development"><i class="fa fa-check"></i>Development</a></li>
<li class="chapter" data-level="" data-path="index.html"><a href="index.html#reproducibility"><i class="fa fa-check"></i>Reproducibility</a></li>
</ul></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#what-is-geocomputation"><i class="fa fa-check"></i><b>1.1</b> What is geocomputation?</a></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#why-geocomputation-with-r"><i class="fa fa-check"></i><b>1.2</b> Why Geocomputation with R?</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#software-for-geocomputation"><i class="fa fa-check"></i><b>1.3</b> Software for geocomputation</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#rs-spatial-ecosystem"><i class="fa fa-check"></i><b>1.4</b> R’s spatial ecosystem</a></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#rs-spatial-history"><i class="fa fa-check"></i><b>1.5</b> R’s spatial history</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#exercises"><i class="fa fa-check"></i><b>1.6</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="spatial-class.html"><a href="spatial-class.html"><i class="fa fa-check"></i><b>2</b> Geographic data in R</a><ul>
<li class="chapter" data-level="" data-path="spatial-class.html"><a href="spatial-class.html#prerequisites"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="2.1" data-path="spatial-class.html"><a href="spatial-class.html#vector-data"><i class="fa fa-check"></i><b>2.1</b> Vector data</a><ul>
<li class="chapter" data-level="2.1.1" data-path="spatial-class.html"><a href="spatial-class.html#intro-sf"><i class="fa fa-check"></i><b>2.1.1</b> An introduction to simple features</a></li>
<li class="chapter" data-level="2.1.2" data-path="spatial-class.html"><a href="spatial-class.html#why-simple-features"><i class="fa fa-check"></i><b>2.1.2</b> Why Simple Features?</a></li>
<li class="chapter" data-level="2.1.3" data-path="spatial-class.html"><a href="spatial-class.html#basic-map"><i class="fa fa-check"></i><b>2.1.3</b> Basic map making</a></li>
<li class="chapter" data-level="2.1.4" data-path="spatial-class.html"><a href="spatial-class.html#sf_classes"><i class="fa fa-check"></i><b>2.1.4</b> Simple feature classes</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="spatial-class.html"><a href="spatial-class.html#raster-data"><i class="fa fa-check"></i><b>2.2</b> Raster data</a><ul>
<li class="chapter" data-level="2.2.1" data-path="spatial-class.html"><a href="spatial-class.html#an-introduction-to-raster"><i class="fa fa-check"></i><b>2.2.1</b> An introduction to raster</a></li>
<li class="chapter" data-level="2.2.2" data-path="spatial-class.html"><a href="spatial-class.html#basic-map-making"><i class="fa fa-check"></i><b>2.2.2</b> Basic map making</a></li>
<li class="chapter" data-level="2.2.3" data-path="spatial-class.html"><a href="spatial-class.html#raster-classes"><i class="fa fa-check"></i><b>2.2.3</b> Raster classes</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="spatial-class.html"><a href="spatial-class.html#crs-intro"><i class="fa fa-check"></i><b>2.3</b> Coordinate Reference Systems</a></li>
<li class="chapter" data-level="2.4" data-path="spatial-class.html"><a href="spatial-class.html#units"><i class="fa fa-check"></i><b>2.4</b> Units</a></li>
<li class="chapter" data-level="2.5" data-path="spatial-class.html"><a href="spatial-class.html#exercises-1"><i class="fa fa-check"></i><b>2.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="attr.html"><a href="attr.html"><i class="fa fa-check"></i><b>3</b> Attribute data operations</a><ul>
<li class="chapter" data-level="" data-path="attr.html"><a href="attr.html#prerequisites-1"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="3.1" data-path="attr.html"><a href="attr.html#introduction"><i class="fa fa-check"></i><b>3.1</b> Introduction</a></li>
<li class="chapter" data-level="3.2" data-path="attr.html"><a href="attr.html#vector-attribute-manipulation"><i class="fa fa-check"></i><b>3.2</b> Vector attribute manipulation</a><ul>
<li class="chapter" data-level="3.2.1" data-path="attr.html"><a href="attr.html#vector-attribute-subsetting"><i class="fa fa-check"></i><b>3.2.1</b> Vector attribute subsetting</a></li>
<li class="chapter" data-level="3.2.2" data-path="attr.html"><a href="attr.html#vector-attribute-aggregation"><i class="fa fa-check"></i><b>3.2.2</b> Vector attribute aggregation</a></li>
<li class="chapter" data-level="3.2.3" data-path="attr.html"><a href="attr.html#vector-attribute-joining"><i class="fa fa-check"></i><b>3.2.3</b> Vector attribute joining</a></li>
<li class="chapter" data-level="3.2.4" data-path="attr.html"><a href="attr.html#creating-attributes-and-removing-spatial-information"><i class="fa fa-check"></i><b>3.2.4</b> Creating attributes and removing spatial information</a></li>
</ul></li>
<li class="chapter" data-level="3.3" data-path="attr.html"><a href="attr.html#manipulating-raster-objects"><i class="fa fa-check"></i><b>3.3</b> Manipulating raster objects</a><ul>
<li class="chapter" data-level="3.3.1" data-path="attr.html"><a href="attr.html#raster-subsetting"><i class="fa fa-check"></i><b>3.3.1</b> Raster subsetting</a></li>
<li class="chapter" data-level="3.3.2" data-path="attr.html"><a href="attr.html#summarizing-raster-objects"><i class="fa fa-check"></i><b>3.3.2</b> Summarizing raster objects</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="attr.html"><a href="attr.html#exercises-2"><i class="fa fa-check"></i><b>3.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html"><i class="fa fa-check"></i><b>4</b> Spatial data operations</a><ul>
<li class="chapter" data-level="" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#prerequisites-2"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="4.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#introduction-1"><i class="fa fa-check"></i><b>4.1</b> Introduction</a></li>
<li class="chapter" data-level="4.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-subsetting"><i class="fa fa-check"></i><b>4.2</b> Spatial subsetting</a></li>
<li class="chapter" data-level="4.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-joining-and-aggregation"><i class="fa fa-check"></i><b>4.3</b> Spatial joining and aggregation</a><ul>
<li class="chapter" data-level="4.3.1" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-congruence-and-areal-interpolation"><i class="fa fa-check"></i><b>4.3.1</b> Spatial congruence and areal interpolation</a></li>
<li class="chapter" data-level="4.3.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#non-overlapping-joins"><i class="fa fa-check"></i><b>4.3.2</b> Non-overlapping joins</a></li>
</ul></li>
<li class="chapter" data-level="4.4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#topological-relations"><i class="fa fa-check"></i><b>4.4</b> Topological relations</a></li>
<li class="chapter" data-level="4.5" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#modifying-geometry-data"><i class="fa fa-check"></i><b>4.5</b> Modifying geometry data</a></li>
<li class="chapter" data-level="4.6" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#distance-relations"><i class="fa fa-check"></i><b>4.6</b> Distance relations</a></li>
<li class="chapter" data-level="4.7" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#spatial-operations-on-raster-data"><i class="fa fa-check"></i><b>4.7</b> Spatial operations on raster data</a><ul>
<li class="chapter" data-level="4.7.1" data-path="attr.html"><a href="attr.html#raster-subsetting"><i class="fa fa-check"></i><b>4.7.1</b> Spatial subsetting</a></li>
<li class="chapter" data-level="4.7.2" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#map-algebra"><i class="fa fa-check"></i><b>4.7.2</b> Map algebra</a></li>
<li class="chapter" data-level="4.7.3" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#merging-rasters"><i class="fa fa-check"></i><b>4.7.3</b> Merging rasters</a></li>
<li class="chapter" data-level="4.7.4" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#aligning-rasters"><i class="fa fa-check"></i><b>4.7.4</b> Aligning rasters</a></li>
<li class="chapter" data-level="4.7.5" data-path="spatial-data-operations.html"><a href="spatial-data-operations.html#exercises-3"><i class="fa fa-check"></i><b>4.7.5</b> Exercises</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="read-write.html"><a href="read-write.html"><i class="fa fa-check"></i><b>5</b> Geographic data I/O</a><ul>
<li class="chapter" data-level="5.1" data-path="read-write.html"><a href="read-write.html#data-input-i"><i class="fa fa-check"></i><b>5.1</b> Data Input (I)</a><ul>
<li class="chapter" data-level="5.1.1" data-path="read-write.html"><a href="read-write.html#vector-data-1"><i class="fa fa-check"></i><b>5.1.1</b> Vector data</a></li>
<li class="chapter" data-level="5.1.2" data-path="read-write.html"><a href="read-write.html#raster-data-1"><i class="fa fa-check"></i><b>5.1.2</b> Raster data</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="read-write.html"><a href="read-write.html#data-output-o"><i class="fa fa-check"></i><b>5.2</b> Data output (O)</a><ul>
<li class="chapter" data-level="5.2.1" data-path="read-write.html"><a href="read-write.html#vector-data-2"><i class="fa fa-check"></i><b>5.2.1</b> Vector data</a></li>
<li class="chapter" data-level="5.2.2" data-path="read-write.html"><a href="read-write.html#raster-data-2"><i class="fa fa-check"></i><b>5.2.2</b> Raster data</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="read-write.html"><a href="read-write.html#file-formats"><i class="fa fa-check"></i><b>5.3</b> File formats</a></li>
<li class="chapter" data-level="5.4" data-path="read-write.html"><a href="read-write.html#visual-outputs"><i class="fa fa-check"></i><b>5.4</b> Visual outputs</a></li>
<li class="chapter" data-level="5.5" data-path="read-write.html"><a href="read-write.html#exercises-4"><i class="fa fa-check"></i><b>5.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="adv-map.html"><a href="adv-map.html"><i class="fa fa-check"></i><b>6</b> Advanced map making</a><ul>
<li class="chapter" data-level="" data-path="adv-map.html"><a href="adv-map.html#prerequisites-3"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="6.1" data-path="adv-map.html"><a href="adv-map.html#facetted-maps"><i class="fa fa-check"></i><b>6.1</b> Facetted maps</a></li>
<li class="chapter" data-level="6.2" data-path="adv-map.html"><a href="adv-map.html#animations"><i class="fa fa-check"></i><b>6.2</b> Animations</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>7</b> References</a></li>
<li class="divider"></li>
<li><a href="http://robinlovelace.net/">Robin Lovelace</a></li>
<li><a href="https://nowosad.github.io/">Jakub Nowosad</a></li>
<li><a href="http://www.geographie.uni-jena.de/en/Muenchow.html">Jannes Muenchow</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Geocomputation with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="spatial-class" class="section level1">
<h1><span class="header-section-number">2</span> Geographic data in R</h1>
<div id="prerequisites" class="section level2 unnumbered">
<h2>Prerequisites</h2>
<p>This is the first practical chapter of the book, and therefore it comes with some software requirements. We assume that you have installed on your computer a recent version of R and that you are comfortable using it at the command line, e.g., via an integrated development environment (IDE) such as RStudio (recommended). R/RStudio works on all major operating systems. You can install and set up both in a few minutes on most modern computers, as described in <a href="https://csgillespie.github.io/efficientR/set-up.html#r-version">section 2.3</a> and <a href="https://csgillespie.github.io/efficientR/set-up.html#rstudio">section 2.5</a> of <span class="citation">Gillespie and Lovelace (<a href="#ref-gillespie_efficient_2016">2016</a>)</span> (other guides are available).</p>
<p>If you are not a regular R user, we recommend that you familiarize yourself with the language before proceeding with this chapter. You can do so using resources such as <span class="citation">Gillespie and Lovelace (<a href="#ref-gillespie_efficient_2016">2016</a>)</span>, <span class="citation">Grolemund and Wickham (<a href="#ref-grolemund_r_2016">2016</a>)</span> as well as online interactive guides such as <a href="https://www.datacamp.com/courses/free-introduction-to-r">DataCamp</a>. It is also worth to spend time to establish an efficient programming workflow, for example with the help of an RStudio ‘<a href="https://csgillespie.github.io/efficientR/set-up.html#project-management">project</a>’. Subsequently, you can use the RStudio project provided in the root directory of the <a href="https://github.com/Robinlovelace/geocompr"><code>geocompr</code></a> GitHub repository. This will make it easier to run this book’s worked examples on your computer.</p>
<hr />
<p>After having successfully installed R, you have to install and load add-on packages to handle spatial data. On Mac and Linux operating systems there are a few additional requirements: see the <a href="https://github.com/r-spatial/sf">README</a> of the <strong>sf</strong> package for instructions. The <strong>sf</strong>, <strong>raster</strong>, <strong>spData</strong>, and <strong>spDataLarge</strong> packages used in this chapter can be installed and loaded with the following commands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="st">&quot;sf&quot;</span>)
<span class="kw">install.packages</span>(<span class="st">&quot;raster&quot;</span>)
<span class="kw">install.packages</span>(<span class="st">&quot;spData&quot;</span>)
<span class="kw">library</span>(sf)
<span class="kw">library</span>(raster)
<span class="kw">library</span>(spData)
<span class="kw">install.packages</span>(<span class="st">&quot;spDataLarge&quot;</span>)
<span class="kw">library</span>(spDataLarge)</code></pre></div>
<p>This chapter will provide brief explanations of the fundamental geographic data models: vector and raster. We will introduce briefly the theory behind both data models, and then move quickly towards how these are implemented in R. Vector and raster models are vital to geospatial analysis <span class="citation">(Longley <a href="#ref-longley_geographic_2015">2015</a>)</span>. The vector data model represents the world using points, lines and polygons. This means, it supports data with discrete, well-defined borders. Generally, vector datasets have a high level of precision (but not necessarily accuracy as we will see in <a href="spatial-class.html#units">2.4</a>). On the other hand, the raster data model is good at representing continuous phenomena such as elevation or rainfall with the help of grid cell that break the surface up into a cells of constant size (<em>resolution</em>). Rasters, therefore, aggregate spatially specific features to a given resolution resulting in small features being blurred or lost. <!-- todo: add figure(s) showing raster data and blurring? --> Naturally, it depends on your discipline if you more often user raster or vector data:</p>
<ul>
<li>Vector data tends to dominate the social sciences because human settlements and boundaries have discrete borders.</li>
<li>By contrast, raster data often dominates the environmental sciences because these often use remotely sensed imagery.</li>
</ul>
<p>However, there is a substantial level of overlap: ecologists and demographers, for example, commonly use both vector and raster data. We, therefore, strongly recommend learning about each data model before proceeding to understand how to manipulate them in subsequent chapters. This book uses <strong>sf</strong> and <strong>raster</strong> packages to work with vector data and raster datasets respectively.</p>
</div>
<div id="vector-data" class="section level2">
<h2><span class="header-section-number">2.1</span> Vector data</h2>
<p>The geographic vector model is based on points that are located on a Cartesian (or geographic) coordinate system.<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> Typically, a point consists of an x and a y value. These two numbers simply represent the distance from the <span class="math inline">\(origin\)</span> along the <span class="math inline">\(x\)</span> (horizontal) and <span class="math inline">\(y\)</span> (vertical) axis in Euclidean space.<a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a> In mathematical notation these points are typically represented as numbers separated by commas and enclosed by a pair of brackets: <span class="math inline">\((1, 3)\)</span> for example, represents a point located one unit to the right and three units above the origin. Instead of creating these points manually, one would commonly read-in data with functions such as <code>read_csv()</code> from the <strong>tidyverse</strong> or <code>read_sf()</code> from the <strong>sf</strong> package (see chapter <a href="read-write.html#read-write">5</a>). To generate new data (e.g., for testing), one can use the command <code>c()</code> (think of ‘c’ for ‘combine’), as illustrated below:<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">p =<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>)</code></pre></div>
<p>Now this can be plotted in Cartesian space, as illustrated in figure <a href="spatial-class.html#fig:cartesian">2.1</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="dt">x =</span> p[<span class="dv">1</span>], <span class="dt">y =</span> p[<span class="dv">2</span>], <span class="dt">xlim =</span>  <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>), <span class="dt">ylim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">5</span>))</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:cartesian"></span>
<img src="figures/cartesian-1.png" alt="Illustration of vector point data in base R." width="576" />
<p class="caption">
Figure 2.1: Illustration of vector point data in base R.
</p>
</div>
<div id="intro-sf" class="section level3">
<h3><span class="header-section-number">2.1.1</span> An introduction to simple features</h3>
<p>Simple features is an open standard developed and endorsed by the Open Geospatial Consortium (<a href="http://portal.opengeospatial.org/files/?artifact_id=25355">OGC</a>) to represent a wide range of geographical information. It is a hierarchical data model that simplifies geographic data by condensing a complex range of geographic forms into a single geometry class. Only 7 out of 68 possible types of simple feature are currently used in the vast majority of GIS operations (Figure <a href="spatial-class.html#fig:sf-ogc">2.2</a>). The R package <strong>sf</strong> <span class="citation">(Pebesma <a href="#ref-R-sf">2017</a>)</span> fully supports all of these (including plotting methods etc.).<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a></p>
<div class="figure" style="text-align: center"><span id="fig:sf-ogc"></span>
<img src="figures/sf-classes.png" alt="The subset of the Simple Features class hierarchy supported by sf. Figure based on the Open Geospatial Consortium document [06-103r4](http://www.opengeospatial.org/standards/sfa)." width="100%" />
<p class="caption">
Figure 2.2: The subset of the Simple Features class hierarchy supported by sf. Figure based on the Open Geospatial Consortium document <a href="http://www.opengeospatial.org/standards/sfa">06-103r4</a>.
</p>
</div>
<p><strong>sf</strong> can represent all common vector geometry types (raster data classes are not supported by <strong>sf</strong>): points, lines, polygons and their respective ‘multi’ versions (which group together features of the same type into a single feature). <strong>sf</strong> also supports geometry collections, which can contain multiple geometry types in a single object. Given the breadth of geographic data forms, it may come as a surprise that a class system to support all of them is provided in a single package, which can be installed from CRAN:<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a> <strong>sf</strong> incorporates the functionality of the three main packages of the <strong>sp</strong> paradigm (<strong>sp</strong> <span class="citation">(Pebesma and Bivand <a href="#ref-R-sp">2017</a>)</span> for the class system, <strong>rgdal</strong> <span class="citation">(Bivand, Keitt, and Rowlingson <a href="#ref-R-rgdal">2017</a>)</span> for reading and writing data, <strong>rgeos</strong> <span class="citation">(Bivand and Rundel <a href="#ref-R-rgeos">2017</a>)</span> for spatial operations undertaken by GEOS) in a single, cohesive whole. This is well-documented in <strong>sf</strong>’s <a href="http://cran.rstudio.com/package=sf">vignettes</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">vignette</span>(<span class="st">&quot;sf1&quot;</span>) <span class="co"># for an introduction to the package</span>
<span class="kw">vignette</span>(<span class="st">&quot;sf2&quot;</span>) <span class="co"># for reading, writing and converting Simple Features</span>
<span class="kw">vignette</span>(<span class="st">&quot;sf3&quot;</span>) <span class="co"># for manipulating Simple Features</span></code></pre></div>
<p>As the first vignette explains, simple feature objects in R are stored in a data frame, with geographic data occupying a special column, a ‘list-column’. This column is usually named ‘geom’ or ‘geometry’. Let us load a ‘real world’ example, here the <code>world</code> dataset, with the help of the <strong>spData</strong> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spData)</code></pre></div>
<p><strong>spData</strong> silently loaded the <code>world</code> dataset (and many other spatial datasets - see <a href="https://nowosad.github.io/spData/">the spData website</a> for a full list). This dataset contains spatial and non-spatial information, as shown by the function <code>names()</code>, which reports the column headings in data frames. Please note that the last column contains the geographic information:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(world)
<span class="co">#&gt;  [1] &quot;iso_a2&quot;    &quot;name_long&quot; &quot;continent&quot; &quot;region_un&quot; &quot;subregion&quot;</span>
<span class="co">#&gt;  [6] &quot;type&quot;      &quot;area_km2&quot;  &quot;pop&quot;       &quot;lifeExp&quot;   &quot;gdpPercap&quot;</span>
<span class="co">#&gt; [11] &quot;geom&quot;</span></code></pre></div>
<p>It is the contents of this modest-looking <code>geom</code> column that gives <code>sf</code> objects their spatial powers. This so-called list-column contains all the coordinates. <strong>sf</strong>’s <code>plot()</code> method uses these coordinates to create a map (Figure <a href="spatial-class.html#fig:world-all">2.3</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sf) <span class="co"># must be loaded to plot sf objects</span>
<span class="co">#&gt; Linking to GEOS 3.5.0, GDAL 2.1.0, proj.4 4.8.0</span>
<span class="kw">plot</span>(world)
<span class="co">#&gt; Warning: plotting the first 9 out of 10 attributes; use max.plot = 10 to</span>
<span class="co">#&gt; plot all</span></code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:world-all"></span>
<img src="figures/world-all-1.png" alt="A spatial plot of the world using the sf package, with a facet for each attribute." width="576" />
<p class="caption">
Figure 2.3: A spatial plot of the world using the sf package, with a facet for each attribute.
</p>
</div>
<p>Note that instead of creating a single map, as most GIS programs would, the <code>plot()</code> command has created multiple maps, one for each variable in the <code>world</code> datasets. This behavior can be useful for exploring the spatial distribution of different variables and is discussed further in <a href="spatial-class.html#basic-map">2.1.3</a> below.</p>
<p>Being able to treat spatial objects as regular data frames with spatial powers has many advantages, especially if you are already used to working with data frames. The commonly used <code>summary()</code> function, for example, provides a useful overview of the variables within the <code>world</code> object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(world[<span class="st">&quot;lifeExp&quot;</span>])
<span class="co">#&gt;     lifeExp                geom    </span>
<span class="co">#&gt;  Min.   :48.9   MULTIPOLYGON :177  </span>
<span class="co">#&gt;  1st Qu.:64.3   epsg:4326    :  0  </span>
<span class="co">#&gt;  Median :72.8   +proj=long...:  0  </span>
<span class="co">#&gt;  Mean   :70.6                      </span>
<span class="co">#&gt;  3rd Qu.:77.1                      </span>
<span class="co">#&gt;  Max.   :83.6                      </span>
<span class="co">#&gt;  NA&#39;s   :9</span></code></pre></div>
<p>Although we have only selected one variable for the <code>summary</code> command, it also outputs an report on the geometry (we explore such ‘attribute operations’ in more depth in Chapter <a href="attr.html#attr">3</a>). This is due to the sticky behavior of the geometry columns of <strong>sf</strong> objects (see Chapter <a href="attr.html#attr">3</a>). Hence, the result provides a quick summary of both the non-spatial and spatial data contained in <code>world</code>: the average life expectancy is 73 years (ranging from less than 50 to more than 80 years) across all countries which are represented in the form of <code>MULTIPOLYGON</code>s. <code>MULTIPOLYGON</code>s allow more than one polygon per row (here: country). This representation is necessary for countries with many islands such as Indonesia and Greece.</p>
<!-- TODO: cross-reference section covering CRSs. -->
<p>It is worth taking a deeper look at the basic behavior and contents of this simple feature object, which can usefully be thought of as a ’<strong>S</strong>patial data<strong>F</strong>rame).</p>
<p><code>sf</code> objects are easy to subset. The code below shows its first two rows and three columns. The output shows two major differences compared with a regular <code>data.frame</code>: the inclusion of additional geographic data (<code>geometry type</code>, <code>dimension</code>, <code>bbox</code> and CRS information - <code>epsg (SRID)</code>, <code>proj4string</code>), and the presence of final <code>geometry</code> column:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world[<span class="dv">1</span>:<span class="dv">2</span>, <span class="dv">1</span>:<span class="dv">3</span>]
<span class="co">#&gt; Simple feature collection with 2 features and 3 fields</span>
<span class="co">#&gt; geometry type:  MULTIPOLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 11.6401 ymin: -17.93064 xmax: 75.15803 ymax: 38.48628</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt;   iso_a2   name_long continent                           geom</span>
<span class="co">#&gt; 1     AF Afghanistan      Asia MULTIPOLYGON (((61.21081709...</span>
<span class="co">#&gt; 2     AO      Angola    Africa MULTIPOLYGON (((16.32652835...</span></code></pre></div>
<p>All this may seem rather complex, especially for a class system that is supposed to be simple. However, there are good reasons for organizing things this way and using <strong>sf</strong>.</p>
<!-- It's a `MULTIPOLYGON` with 177 features and a geographical (longitude/latidue) coordinate reference system (CRS) with an EPSG code of `4326`. -->
</div>
<div id="why-simple-features" class="section level3">
<h3><span class="header-section-number">2.1.2</span> Why Simple Features?</h3>
<p>There are many advantages of <strong>sf</strong> over <strong>sp</strong>, including:</p>
<ul>
<li>Faster reading and writing of data (more than 10 times faster in some cases)</li>
<li>Better plotting performance</li>
<li><strong>sf</strong> objects can be treated as data frames in most operations</li>
<li><strong>sf</strong> functions can be combined using <code>%&gt;%</code> operator and works well with the <a href="http://tidyverse.org/">tidyverse</a> collection of R packages</li>
<li><strong>sf</strong> function names are relatively consistent and intuitive (all begin with <code>st_</code>) compared with the function names and syntax of the <strong>sp</strong>, <strong>rgdal</strong> and <strong>rgeos</strong> packages that it supersedes.</li>
</ul>
<p>A broader advantage is that simple features are so well-supported by other software products, not least PostGIS, which has heavily influenced the design of <strong>sf</strong>.</p>
<p>A disadvantage you should be aware of, however, is that <strong>sf</strong> is not <em>feature complete</em> and that it continues to evolve. The transition from <strong>sp</strong> to <strong>sf</strong> will likely take many years, and many spatial packages may never switch. Even if you discover spatial data with R through the <strong>sf</strong> package, it is still worth at least being aware of <strong>sp</strong> classes, even if you rarely use them for everyday geospatial tasks.</p>
<p>Fortunately it is easy to translate between <strong>sp</strong> and <strong>sf</strong> using the <code>as()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(sp)
world_sp =<span class="st"> </span><span class="kw">as</span>(<span class="dt">object =</span> world, <span class="dt">Class =</span> <span class="st">&quot;Spatial&quot;</span>)</code></pre></div>
<p><span class="citation">Bivand, Pebesma, and Gómez-Rubio (<a href="#ref-bivand_applied_2013">2013</a>)</span> provides an excellent introduction to <strong>sp</strong>.</p>
</div>
<div id="basic-map" class="section level3">
<h3><span class="header-section-number">2.1.3</span> Basic map making</h3>
<p>You can quickly create basic maps in <strong>sf</strong> with the base <code>plot()</code> function. By default, <strong>sf</strong> creates a multi-panel plot (like <strong>sp</strong>’s <code>spplot()</code>), one sub-plot for each variable (see left-hand image in Figure <a href="spatial-class.html#fig:sfplot">2.4</a>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(world[<span class="dv">3</span>:<span class="dv">4</span>])
<span class="kw">plot</span>(world[<span class="st">&quot;pop&quot;</span>])</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:sfplot"></span>
<img src="figures/sfplot-1.png" alt="Plotting with sf, with multiple variables (left) and a single variable (right)." width="49%" /><img src="figures/sfplot-2.png" alt="Plotting with sf, with multiple variables (left) and a single variable (right)." width="49%" />
<p class="caption">
Figure 2.4: Plotting with sf, with multiple variables (left) and a single variable (right).
</p>
</div>
<p>As with <strong>sp</strong>, you can add further layers to your maps using the <code>add = TRUE</code>-argument of the <code>plot()</code> function .<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a> To illustrate this, and prepare for content covered in chapters <a href="attr.html#attr">3</a> and <a href="spatial-data-operations.html#spatial-data-operations">4</a> on attribute and spatial data operations, we will subset and combine countries in the <code>world</code> object, which creates a single object representing Asia:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">asia =<span class="st"> </span>world[world$continent ==<span class="st"> &quot;Asia&quot;</span>, ]
asia =<span class="st"> </span><span class="kw">st_union</span>(asia)</code></pre></div>
<p>We can now plot the Asian continent over a map of the world. Note, however, that this only works if the initial plot has only one layer:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(world[<span class="st">&quot;pop&quot;</span>])
<span class="kw">plot</span>(asia, <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:asia"></span>
<img src="figures/asia-1.png" alt="A plot of Asia added as a layer on top of countries worldwide." width="50%" />
<p class="caption">
Figure 2.5: A plot of Asia added as a layer on top of countries worldwide.
</p>
</div>
<p>This can be very useful for quickly checking the geographic correspondence between two or more layers: the <code>plot()</code> function is fast to execute and requires few lines of code, but does not create interactive maps with a wide range of options. For more advanced map making we recommend using a dedicated visualization package such as <strong>tmap</strong>, <strong>ggplot2</strong>, <strong>mapview</strong>, or <strong>leaflet</strong>. <!-- TODO: cross reference advanced mapping chapter --></p>
<!-- 
- plot() function 
- map export 
-->
<!-- Maybe show also somewhere that `world[0]` produces only a plot of the geometry which is rather useful if you do not want to plot a specific attribute. This way, you can for example dismiss the col = "white"-argument in your Nigeria example.
Sorry for commenting on this again but just to clarify africa[0] selects zero columns but since the geometry column is sticky it won't be dismissed. Neverthess, to be more explicit one should probably use plot(st_geometry(africa))-->
<div id="further-work" class="section level4">
<h4><span class="header-section-number">2.1.3.1</span> Further work</h4>
<p><strong>sf</strong> simplifies spatial data objects compared with <strong>sp</strong> and provides a near-direct interface to GDAL and GEOS C++ functions. In theory this should make <strong>sf</strong> faster than <strong>sp</strong>/<strong>rgdal</strong>/<strong>rgeos</strong>, something that is tested in Chapter 5 for data I/O. This section introduces <strong>sf</strong> classes in preparation for subsequent chapters which deal with vector data (in particular Chapter <a href="spatial-data-operations.html#spatial-data-operations">4</a>).</p>
<p>As a final exercise, we will see one way of how to do a spatial overlay in <strong>sf</strong>. First, we convert the countries of the world into centroids, and then subset those in Asia. Finally, the <code>summary</code>-command tells us how many centroids (countries) are part of Asia (43) and how many are not (134).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">world_centroids =<span class="st"> </span><span class="kw">st_centroid</span>(world)
<span class="co">#&gt; Warning in st_centroid.sfc(st_geometry(x), of_largest_polygon =</span>
<span class="co">#&gt; of_largest_polygon): st_centroid does not give correct centroids for</span>
<span class="co">#&gt; longitude/latitude data</span>
sel_asia =<span class="st"> </span><span class="kw">st_intersects</span>(world_centroids, asia, <span class="dt">sparse =</span> <span class="ot">FALSE</span>)
<span class="co">#&gt; although coordinates are longitude/latitude, it is assumed that they are planar</span>
<span class="kw">summary</span>(sel_asia)
<span class="co">#&gt;      V1         </span>
<span class="co">#&gt;  Mode :logical  </span>
<span class="co">#&gt;  FALSE:134      </span>
<span class="co">#&gt;  TRUE :43</span></code></pre></div>
<p>Note: <code>st_intersects()</code> uses <a href="https://trac.osgeo.org/geos/">GEOS</a> in the background for the spatial overlay operation (see also Chapter <a href="spatial-data-operations.html#spatial-data-operations">4</a>).</p>
<p>Since <strong>sf</strong>’s <code>plot()</code> function builds on base plotting methods, you may also use its many optional arguments (see <code>?plot</code> and <code>?par</code>). This provides powerful but not necessarily intuitive functionality. For instance, in order to make the diameter of a circle proportional to a country’s population, we provide the <code>cex</code> argument with the result of a calculation (see Figure <a href="spatial-class.html#fig:africa">2.6</a>, and the code below).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(world[<span class="st">&quot;continent&quot;</span>])
<span class="kw">plot</span>(world_centroids, <span class="dt">add =</span> <span class="ot">TRUE</span>, <span class="dt">cex =</span> world$pop /<span class="st"> </span><span class="fl">1e8</span>, <span class="dt">lwd =</span> <span class="dv">3</span>)</code></pre></div>
<div class="figure" style="text-align: center"><span id="fig:africa"></span>
<img src="figures/africa-1.png" alt="Centroids representing country population, diameter being proportional to population." width="576" />
<p class="caption">
Figure 2.6: Centroids representing country population, diameter being proportional to population.
</p>
</div>
<!-- More appropriate for subsequent chapters. -->
<!-- This shows that there are 43 countries in Asia -->
<!-- We can check if they are the same countries as follows: -->
<!-- ```{r} -->
<!-- africa_centroids2 = world_centroids[sel_africa, ] -->
<!-- identical(africa_centroids, africa_centroids2) -->
<!-- ``` -->
</div>
</div>
<div id="sf_classes" class="section level3">
<h3><span class="header-section-number">2.1.4</span> Simple feature classes</h3>
<p>To understand new data formats in depth, it often helps to build them from the ground up. This section walks you through vector spatial classes step-by-step, from the elementary simple feature geometry to simple feature objects of class <code>sf</code> representing complex spatial data. Before describing each geometry type that the <strong>sf</strong> package supports, it is worth taking a step back to understand the building blocks of <code>sf</code> objects. As stated in section <a href="spatial-class.html#intro-sf">2.1.1</a>, simple features are simply data frames with at least one special column that makes it spatial. These spatial columns are often called <code>geom</code> or <code>geometry</code> and can be like non-spatial columns: <code>world$geom</code> refers to the spatial element of the <code>world</code> object described above. These geometry columns are ‘list columns’ of class <code>sfc</code>: they are simple feature collections. In turn, <code>sfc</code> objects are composed of one or more objects of class <code>sfg</code>: simple feature geometries.</p>
<p>To understand how the spatial components of simple features work, it is vital to understand simple feature geometries. For this reason we cover each currently supported <code>sfg</code> type in the next subsections before moving on to describe how these can be combined to form <code>sfc</code> and eventually full <code>sf</code> objects.</p>
<div id="geometry" class="section level4">
<h4><span class="header-section-number">2.1.4.1</span> Simple feature geometry types</h4>
<!-- This section demonstrates how the full range of geometry types supported by the **sf** package can be created, combined and plotted. -->
<p>Geometries are the basic building blocks of simple features. Simple features in R can take on one of the 17 geometry types supported by the <strong>sf</strong> package. In this chapter we will focus on the seven most commonly used types: <code>POINT</code>, <code>LINESTRING</code>, <code>POLYGON</code>, <code>MULTIPOINT</code>, <code>MULTILINESTRING</code>, <code>MULTIPOLYGON</code> and <code>GEOMETRYCOLLECTION</code>.<!--FIG--> Find the whole list of possible feature types in <a href="http://postgis.net/docs/using_postgis_dbmanagement.html">the PostGIS manual</a>.</p>
<p>Generally, well-known binary (WKB) or well-known text (WKT) are the standard encoding for simple feature geometries. WKB representations are usually hexadecimal strings easily readable for computers. This is why, GIS and spatial databases use WKB to transfer and store geometry objects. WKT, on the other hand, is a human-readable text markup description of simple features. Both formats are exchangeable, and if we present one, we will naturally choose the WKT representation.</p>
<p>The basis for each geometry type is the point. A point is simply a coordinate in 2D, 3D or 4D space (see <code>vignette(&quot;sf1&quot;)</code> for more information) such as:</p>
<ul>
<li><code>POINT (5 2)</code></li>
</ul>
<p><img src="figures/point-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>A linestring is a sequence of points with a straight line connecting the points, for example:</p>
<ul>
<li><code>LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)</code></li>
</ul>
<p><img src="figures/linestring-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>A polygon is a sequence of points that form a closed, non-intersecting ring. Closed means that the first and the last point of a polygon have the same coordinates. By definition, a polygon has one exterior boundary (outer ring) and can have zero or more interior boundaries (inner rings), also known as holes.</p>
<ul>
<li>Polygon without a hole - <code>POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))</code></li>
</ul>
<p><img src="figures/polygon-1.png" width="576" style="display: block; margin: auto;" /></p>
<ul>
<li>Polygon with one hole - <code>POLYGON ((1 5, 4 4, 4 1, 2 2, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))</code></li>
</ul>
<p><img src="figures/polygon_hole-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>So far, our geometry types have just included one feature. To represent multiple features in one object, we can use the “multi”-version of each geometry type:</p>
<ul>
<li>Multipoint - <code>MULTIPOINT (5 2, 1 3, 3 4, 3 2)</code></li>
<li>Multistring - <code>MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))</code></li>
<li>Multipolygon - <code>MULTIPOLYGON ((1 5, 4 4, 4 1, 2 2, 1 5), (0 2, 1 2, 1 3, 0 3, 0 2))</code></li>
</ul>
<p><img src="figures/multis-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>Finally, a geometry collection might contain any combination of geometry types:</p>
<ul>
<li>Geometry collection - <code>GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)))</code></li>
</ul>
<p><img src="figures/geom_collection-1.png" width="576" style="display: block; margin: auto;" /></p>
</div>
<div id="sfg" class="section level4">
<h4><span class="header-section-number">2.1.4.2</span> Simple feature geometry (sfg) objects</h4>
<p>In R, the <code>sfg</code> class represents the different simple feature geometry types: (multi-)point, (multi-)linestring, (multi-)polygon or geometry collection.</p>
<p>Usually you are spared the tedious task of creating geometries on your own since you can simply import an already existing spatial file. However, there are a set of function to create simple feature geometry objects (<code>sfg</code>) from scratch if needed. The names of these functions are simple and consistent, as they all start with the <code>st_</code> prefix and end with the name of the geometry type in lowercase letters:</p>
<ul>
<li>A point - <code>st_point()</code></li>
<li>A linestring - <code>st_linestring()</code></li>
<li>A polygon - <code>st_polygon()</code></li>
<li>A multipoint - <code>st_multipoint()</code></li>
<li>A multilinestring - <code>st_multilinestring()</code></li>
<li>A multipolygon - <code>st_multipolygon()</code></li>
<li>A geometry collection - <code>st_geometrycollection()</code></li>
</ul>
<p>In R, you create <code>sfg</code> objects with the help of three native data types:</p>
<ol style="list-style-type: decimal">
<li>A numeric vector - a single point</li>
<li>A matrix - a set of points, where each row contains a point - a multipoint or linestring</li>
<li>A list - any other set, e.g. a multilinestring or geometry collection</li>
</ol>
<p>To create point objects, we use the <code>st_point()</code> function in conjunction with a numeric vector:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># note that we use a numeric vector for points</span>
<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>)) <span class="co"># XY point</span>
<span class="co">#&gt; POINT (5 2)</span>
<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">3</span>)) <span class="co"># XYZ point</span>
<span class="co">#&gt; POINT Z (5 2 3)</span>
<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">1</span>), <span class="dt">dim =</span> <span class="st">&quot;XYM&quot;</span>) <span class="co"># XYM point</span>
<span class="co">#&gt; POINT M (5 2 1)</span>
<span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">1</span>)) <span class="co"># XYZM point</span>
<span class="co">#&gt; POINT ZM (5 2 3 1)</span></code></pre></div>
<!-- is this really important? -->
<p>XY, XYZ and XYZM types of points are automatically created based on the length of a numeric vector. Only the XYM type needs to be specified using a <code>dim</code> argument.</p>
<p>By contrast, use matrices in the case of multipoint (<code>st_multipoint()</code>) and linestring (<code>st_linestring()</code>) objects:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># the rbind function simplifies the creation of matrices</span>
## MULTIPOINT
multipoint_matrix =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>))
<span class="kw">st_multipoint</span>(multipoint_matrix)
<span class="co">#&gt; MULTIPOINT (5 2, 1 3, 3 4, 3 2)</span>

## LINESTRING
linestring_matrix =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>))
<span class="kw">st_linestring</span>(linestring_matrix)
<span class="co">#&gt; LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2)</span></code></pre></div>
<p>Finally, use lists for the creation of multilinestrings, (multi-)polygons and geometry collections:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## POLYGON
polygon_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>)))
<span class="kw">st_polygon</span>(polygon_list)
<span class="co">#&gt; POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## POLYGON with a hole
polygon_border =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>))
polygon_hole =<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>))
polygon_with_hole_list =<span class="st"> </span><span class="kw">list</span>(polygon_border, polygon_hole)
<span class="kw">st_polygon</span>(polygon_with_hole_list)
<span class="co">#&gt; POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5), (2 4, 3 4, 3 3, 2 3, 2 4))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## MULTILINESTRING
multilinestring_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)), 
                            <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>)))
<span class="kw">st_multilinestring</span>((multilinestring_list))
<span class="co">#&gt; MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 2, 2 4))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## MULTIPOLYGON
multipolygon_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>))),
                         <span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>))))
<span class="kw">st_multipolygon</span>(multipolygon_list)
<span class="co">#&gt; MULTIPOLYGON (((1 5, 2 2, 4 1, 4 4, 1 5)), ((0 2, 1 2, 1 3, 0 3, 0 2)))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## GEOMETRYCOLLECTION
gemetrycollection_list =<span class="st"> </span><span class="kw">list</span>(<span class="kw">st_multipoint</span>(multipoint_matrix),
                              <span class="kw">st_linestring</span>(linestring_matrix))
<span class="kw">st_geometrycollection</span>(gemetrycollection_list)
<span class="co">#&gt; GEOMETRYCOLLECTION (MULTIPOINT (5 2, 1 3, 3 4, 3 2), LINESTRING (1 5, 4 4, 4 1, 2 2, 3 2))</span></code></pre></div>
<!-- table -->
<!-- figure - image/fig1.jpg -->
<!-- they are interconnected - points could create mulitpoints or lines; -->
<!-- lines could create mutlilines or polygons, etc. -->
<!-- https://r-spatial.github.io/sf/articles/sf1.html -->
</div>
<div id="sfc" class="section level4">
<h4><span class="header-section-number">2.1.4.3</span> Simple feature collections</h4>
<p>One <code>sfg</code> object contains only a single simple feature geometry. A simple feature collection (<code>sfc</code>) is a list of <code>sfg</code> objects and can additionally contain information about the coordinate reference system in use. For instance, to combine two simple features into one object with two features, we can use the <code>st_sfc()</code> function. This is important since this collection represents the geometry column in <strong>sf</strong> data frames:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfc POINT</span>
point1 =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">2</span>))
point2 =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>))
<span class="kw">st_sfc</span>(point1, point2)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT (5 2)</span>
<span class="co">#&gt; POINT (1 3)</span></code></pre></div>
<p>In most cases, an <code>sfc</code> object contains objects of the same geometry type. Therefore, when we convert <code>sfg</code> objects of type polygon into a simple feature collection, we would also end up with an <code>sfc</code> object of type polygon. Equally, a collection of multilinestrings would result in an <code>sfc</code> object of type multilinestring:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfc POLYGON</span>
polygon_list1 =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>)))
polygon1 =<span class="st"> </span><span class="kw">st_polygon</span>(polygon_list)
polygon_list2 =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">3</span>), <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">2</span>)))
polygon2 =<span class="st"> </span><span class="kw">st_polygon</span>(polygon_list2)
<span class="kw">st_sfc</span>(polygon1, polygon2)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POLYGON</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 0 ymin: 1 xmax: 4 ymax: 5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POLYGON ((1 5, 2 2, 4 1, 4 4, 1 5))</span>
<span class="co">#&gt; POLYGON ((0 2, 1 2, 1 3, 0 3, 0 2))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfc MULTILINESTRING</span>
multilinestring_list1 =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">5</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">4</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">2</span>)), 
                            <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">4</span>)))
multilinestring1 =<span class="st"> </span><span class="kw">st_multilinestring</span>((multilinestring_list1))
multilinestring_list2 =<span class="st"> </span><span class="kw">list</span>(<span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">9</span>), <span class="kw">c</span>(<span class="dv">7</span>, <span class="dv">9</span>), <span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">6</span>), <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">7</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">7</span>)), 
                            <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">7</span>), <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">8</span>)))
multilinestring2 =<span class="st"> </span><span class="kw">st_multilinestring</span>((multilinestring_list2))
<span class="kw">st_sfc</span>(multilinestring1, multilinestring2)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  MULTILINESTRING</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 1 xmax: 7 ymax: 9</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 ...</span>
<span class="co">#&gt; MULTILINESTRING ((2 9, 7 9, 5 6, 4 7, 2 7), (1 ...</span></code></pre></div>
<p>It is also possible to create an <code>sfc</code> object from <code>sfg</code> objects with different geometry types:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfc GEOMETRY</span>
<span class="kw">st_sfc</span>(point1, multilinestring1)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  GEOMETRY</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 1 xmax: 5 ymax: 5</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT (5 2)</span>
<span class="co">#&gt; MULTILINESTRING ((1 5, 4 4, 4 1, 2 2, 3 2), (1 ...</span></code></pre></div>
<!-- if you want to use it - st_cast() to a proper geometry type -->
<!-- or st_is to select only one geometry type -->
<!-- http://r-spatial.org/r/2017/01/12/newssf.html -->
<!-- methods(class = "sfc") -->
<p>As mentioned before, <code>sfc</code> objects can additionally store information on the coordinate reference systems (CRS). <!-- What's CRS --> To specify a certain CRS, we can use the <code>epsg (SRID)</code> or <code>proj4string</code> attributes of an <code>sfc</code> object. The default value of <code>epsg (SRID)</code> and <code>proj4string</code> is <code>NA</code> (<em>Not Available</em>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_sfc</span>(point1, point2)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    NA</span>
<span class="co">#&gt; POINT (5 2)</span>
<span class="co">#&gt; POINT (1 3)</span></code></pre></div>
<p>Of course, all geometries in an <code>sfc</code> object must have the same CRS.</p>
<p>We can add coordinate reference system as a <code>crs</code> argument of <code>st_sfc()</code>. This argument accepts either an integer with the <code>epsg</code> code (e.g., <code>4326</code>) or a <code>proj4string</code> character string (e.g., <code>&quot;+proj=longlat +datum=WGS84 +no_defs&quot;</code>):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># EPSG definition</span>
<span class="kw">st_sfc</span>(point1, point2, <span class="dt">crs =</span> <span class="dv">4326</span>)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt; POINT (5 2)</span>
<span class="co">#&gt; POINT (1 3)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># PROJ4STRING definition</span>
<span class="kw">st_sfc</span>(point1, point2, <span class="dt">crs =</span> <span class="st">&quot;+proj=longlat +datum=WGS84 +no_defs&quot;</span>)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt; POINT (5 2)</span>
<span class="co">#&gt; POINT (1 3)</span></code></pre></div>
<p>Both of these approaches have advantages and disadvantages. An <code>epsg</code> code is usually shorter, and therefore easier to remember. The code also refers to only one, well-defined coordinate reference system. On the other hand, a <code>proj4string</code> definition allows you more flexibility when it comes to specifying different parameters such as the projection type, the datum and the ellipsoid. This way you can specify many different projections, and modify existing ones. This makes the <code>proj4string</code> approach also more complicated.<a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a>.</p>
<p><code>epsg</code> always points to exactly one particular CRS. Correspondingly, there is also only one possible <code>proj4string</code> for a specific <code>epsg</code>-code. For example, we can set the UTM Zone 11N projection with <code>epsg</code> code <code>2955</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_sfc</span>(point1, point2, <span class="dt">crs =</span> <span class="dv">2955</span>)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    2955</span>
<span class="co">#&gt; proj4string:    +proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs</span>
<span class="co">#&gt; POINT (5 2)</span>
<span class="co">#&gt; POINT (1 3)</span></code></pre></div>
<p>As you can see above, the <code>proj4string</code> definition was automatically added. Now we can try to set the CRS using <code>proj4string</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_sfc</span>(point1, point2, <span class="dt">crs =</span> <span class="st">&quot;+proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;</span>)
<span class="co">#&gt; Geometry set for 2 features </span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: 1 ymin: 2 xmax: 5 ymax: 3</span>
<span class="co">#&gt; epsg (SRID):    NA</span>
<span class="co">#&gt; proj4string:    +proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs</span>
<span class="co">#&gt; POINT (5 2)</span>
<span class="co">#&gt; POINT (1 3)</span></code></pre></div>
<p>However, the <code>epsg</code> string of our result remained empty. This is because there is no general method to convert from <code>proj4string</code> to <code>epsg</code>.</p>
<!-- precision -->
<!-- plots can be made -->
</div>
<div id="sf" class="section level4">
<h4><span class="header-section-number">2.1.4.4</span> Simple feature objects</h4>
<p>So far, we have only dealt with the pure geometries. Most of the time, however, these geometries come with a set of attributes describing them. These attributes could represent the name of the geometry, measured values, groups to which the geometry belongs, and many more. For example, we measured a temperature of 25°C on Trafalgar Square in London on June 21<sup>th</sup> 2017. Hence, we have a specific point in space (the coordinates), the name of the location (Trafalgar Square), a temperature value, the date of the measurement. Other attributes might include a urbanity category (city or village), or a remark if the measurement was made using an automatic station.</p>
<p>The simple feature class, <code>sf</code>, is a combination of an attribute table (<code>data.frame</code>) and a simple feature geometry collection (<code>sfc</code>). Simple features are created using the <code>st_sf()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># sfg objects</span>
london_point =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(<span class="fl">0.1</span>, <span class="fl">51.5</span>))
ruan_point =<span class="st"> </span><span class="kw">st_point</span>(<span class="kw">c</span>(-<span class="dv">9</span>, <span class="dv">53</span>))

<span class="co"># sfc object</span>
our_geometry =<span class="st"> </span><span class="kw">st_sfc</span>(london_point, ruan_point, <span class="dt">crs =</span> <span class="dv">4326</span>)

<span class="co"># data.frame object</span>
our_attributes =<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">name =</span> <span class="kw">c</span>(<span class="st">&quot;London&quot;</span>, <span class="st">&quot;Ruan&quot;</span>),
                            <span class="dt">temperature =</span> <span class="kw">c</span>(<span class="dv">25</span>, <span class="dv">13</span>),
                            <span class="dt">date =</span> <span class="kw">c</span>(<span class="kw">as.Date</span>(<span class="st">&quot;2017-06-21&quot;</span>), <span class="kw">as.Date</span>(<span class="st">&quot;2017-06-22&quot;</span>)),
                            <span class="dt">category =</span> <span class="kw">c</span>(<span class="st">&quot;city&quot;</span>, <span class="st">&quot;village&quot;</span>),
                            <span class="dt">automatic =</span> <span class="kw">c</span>(<span class="ot">FALSE</span>, <span class="ot">TRUE</span>))

<span class="co"># sf object</span>
sf_points =<span class="st"> </span><span class="kw">st_sf</span>(our_attributes, <span class="dt">geometry =</span> our_geometry)</code></pre></div>
<p>The above example illustrates the components of <code>sf</code> objects. Firstly, coordinates define the geometry of the simple feature geometry (<code>sfg</code>). Secondly, we can combine the geometries in a simple feature collection (<code>sfc</code>) which also stores the CRS. Subsequently, we store the attribute information on the geometries in a <code>data.frame</code>. Finally, the <code>st_sf()</code> function combines the attribute table and the <code>sfc</code> object in an <code>sf</code> object.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sf_points
<span class="co">#&gt; Simple feature collection with 2 features and 5 fields</span>
<span class="co">#&gt; geometry type:  POINT</span>
<span class="co">#&gt; dimension:      XY</span>
<span class="co">#&gt; bbox:           xmin: -9 ymin: 51.5 xmax: 0.1 ymax: 53</span>
<span class="co">#&gt; epsg (SRID):    4326</span>
<span class="co">#&gt; proj4string:    +proj=longlat +datum=WGS84 +no_defs</span>
<span class="co">#&gt;     name temperature       date category automatic         geometry</span>
<span class="co">#&gt; 1 London          25 2017-06-21     city     FALSE POINT (0.1 51.5)</span>
<span class="co">#&gt; 2   Ruan          13 2017-06-22  village      TRUE    POINT (-9 53)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(sf_points)
<span class="co">#&gt; [1] &quot;sf&quot;         &quot;data.frame&quot;</span></code></pre></div>
<p>The result shows that <code>sf</code> objects actually have two classes, <code>sf</code> and <code>data.frame</code>. Simple features are simply data frames (square tables), but with spatial attributes (usually stored in a special <code>geom</code> list-column in the data frame). This duality is central to the concept of simple features: most of the time a <code>sf</code> can be treated as and behaves like a <code>data.frame</code>. Simple features are, in essence, data frames with a spatial extension.</p>
<!-- methods -->
<!-- methods(class = "sf") -->
<!-- plots -->
<!-- https://r-spatial.github.io/sf/articles/sf1.html#how-attributes-relate-to-geometries -->
</div>
</div>
</div>
<div id="raster-data" class="section level2">
<h2><span class="header-section-number">2.2</span> Raster data</h2>
<div class="figure" style="text-align: center"><span id="fig:raster-intro-plot"></span>
<img src="figures/02_raster_intro_plot.png" alt="Raster data: A - a grid representation; B - numbers of the cells; C - values of the cells; D - a final raster map" width="750" />
<p class="caption">
Figure 2.7: Raster data: A - a grid representation; B - numbers of the cells; C - values of the cells; D - a final raster map
</p>
</div>
<p>The geographic raster data model consists of a raster header and a matrix (with rows and columns) representing equally spaced cells (often also called pixels; Figure <a href="spatial-class.html#fig:raster-intro-plot">2.7</a>:A). The raster header defines the coordinate reference system, the extent and the origin. The origin (or starting point) is frequently the coordinate of the lower-left corner of the matrix (the <strong>raster</strong> package, however, uses the upper left corner, by default (Figure <a href="spatial-class.html#fig:raster-intro-plot">2.7</a>:B)). The header defines the extent via the number of columns, the number of rows and the cell size resolution. Hence, starting from the origin, we can easily access and modify each single cell by either using the ID of a cell (Figure <a href="spatial-class.html#fig:raster-intro-plot">2.7</a>:B) or by explicitly specifying the rows and columns. This matrix representation avoids storing explicitly the coordinates for the four corner points (in fact it only stores one coordinate, namely the origin) of each cell corner as would be the case for rectangular vector polygons. This and matrix algebra makes raster processing much more efficient and faster than vector data processing. However, in contrast to vector data, a raster cell can only hold a single value. The value might be numeric or categorical (Figure <a href="spatial-class.html#fig:raster-intro-plot">2.7</a>:C). You can also specify a no-data value in the header of a raster, frequently -9999 (in R we often use <code>NA</code>). Raster maps usually represent continuous phenomena such as elevation, temperature, population density or spectral data (Figure <a href="spatial-class.html#fig:raster-intro-plot2">2.8</a>). Of course, we can represent discrete features such as soil or landcover classes also with the help of a raster data model (Figure <a href="spatial-class.html#fig:raster-intro-plot2">2.8</a>). Consequently, the discrete borders of these features become blurred, and depending on the spatial task a vector representation might be more suitable.</p>
<div class="figure" style="text-align: center"><span id="fig:raster-intro-plot2"></span>
<img src="figures/02_raster_intro_plot2.png" alt="Examples of continuous (left) and categorical (right) raster" width="475" />
<p class="caption">
Figure 2.8: Examples of continuous (left) and categorical (right) raster
</p>
</div>
<div id="an-introduction-to-raster" class="section level3">
<h3><span class="header-section-number">2.2.1</span> An introduction to raster</h3>
<p>The <strong>raster</strong> package supports raster objects in R. It provides an extensive set of functions to create, read, export, manipulate and process raster datasets. Aside from general raster data manipulation, <strong>raster</strong> provides many low level functions that can form the basis to develop more advanced raster functionality. <strong>raster</strong> also lets you work on large raster datasets that are too large to fit into the main memory . In this case, <strong>raster</strong> provides the possibility to divide the raster into smaller chunks (rows or blocks), and processes these iteratively instead of loading the whole raster file into RAM (for more information, please refer to `vignette(“functions”, package = “raster”).</p>
<p>For the illustration of the <strong>raster</strong> concepts, we will use datasets from the <strong>spDataLarge</strong> package. It consists of a few raster and one vector datasets covering an area of the Zion National Park (Utah, USA). For example, <code>srtm.tif</code> is a digital elevation model of this area (for more details - see its documentation <code>?srtm</code>) First of all, we would like to create a <code>RasterLayer</code> object named <code>new_raster</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(spDataLarge)
<span class="kw">library</span>(raster)
raster_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/srtm.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>)
new_raster =<span class="st"> </span><span class="kw">raster</span>(raster_filepath)</code></pre></div>
<p>Typing the name of the raster into the console, will print out the raster header (extent, dimensions, resolution, CRS) and some additional information (class, data source name, summary of the raster values):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">new_raster
<span class="co">#&gt; class       : RasterLayer </span>
<span class="co">#&gt; dimensions  : 463, 459, 212517  (nrow, ncol, ncell)</span>
<span class="co">#&gt; resolution  : 73.7, 92.5  (x, y)</span>
<span class="co">#&gt; extent      : 301929, 335757, 4111262, 4154089  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs </span>
<span class="co">#&gt; data source : /home/travis/R/Library/spDataLarge/raster/srtm.tif </span>
<span class="co">#&gt; names       : srtm </span>
<span class="co">#&gt; values      : 1050, 2895  (min, max)</span></code></pre></div>
<p>To access individual header information, you can use following commands:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># dimensions (number of rows, number of columns, number of cells)</span>
<span class="kw">dim</span>(new_raster)
<span class="co">#&gt; [1] 463 459   1</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># spatial resolution</span>
<span class="kw">res</span>(new_raster)
<span class="co">#&gt; [1] 73.7 92.5</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># spatial extent</span>
<span class="kw">extent</span>(new_raster)
<span class="co">#&gt; class       : Extent </span>
<span class="co">#&gt; xmin        : 301929 </span>
<span class="co">#&gt; xmax        : 335757 </span>
<span class="co">#&gt; ymin        : 4111262 </span>
<span class="co">#&gt; ymax        : 4154089</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># coordinate reference system</span>
<span class="kw">crs</span>(new_raster)
<span class="co">#&gt; CRS arguments:</span>
<span class="co">#&gt;  +proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m</span>
<span class="co">#&gt; +no_defs</span></code></pre></div>
<!--CRSargs(CRS("+init=epsg:4326"))-->
<p>Note that in contrast to the <strong>sf</strong> package, <strong>raster</strong> only accepts the <code>proj4string</code> representation of the coordinate reference system.</p>
<!--
You can also summarize and plot raster cell values in a non-spatial fashion using base R functions such as `summary()` and `hist()`.


```r
# numerical summary of the data
summary(new_raster)
#> Warning in .local(object, ...): summary is an estimate based on a sample of 1e+05 cells (47.06% of all cells)
#>         srtm
#> Min.    1050
#> 1st Qu. 1544
#> Median  1840
#> 3rd Qu. 2121
#> Max.    2895
#> NA's       0
```


```r
# histogram of the values
hist(new_raster)
#> Warning in .hist1(x, maxpixels = maxpixels, main = main, plot = plot, ...):
#> 47% of the raster cells were used. 100000 values used.
```

<img src="figures/new_raster-hist-1.png" width="576" style="display: block; margin: auto;" />

`getValues()` extracts the values of a raster as a numerical vector.
To only select specific rows, use the `row` parameter.


```r
new_raster_values = getValues(new_raster)
head(new_raster_values)
#> [1] 1743 1739 1730 1721 1715 1709
```

The new vector, `new_raster_values`, can serve as input for subsequent statistical operations.
-->
<p>Sometimes it is important to know if all values of a raster are currently in memory or on disk. Find out with the <code>inMemory()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">inMemory</span>(new_raster)
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
<p><code>help(package = &quot;raster&quot;, topic = &quot;raster-package&quot;)</code> returns a full list of all available <strong>raster</strong> functions.</p>
</div>
<div id="basic-map-making" class="section level3">
<h3><span class="header-section-number">2.2.2</span> Basic map making</h3>
<p>Similar to the <strong>sf</strong> package, <strong>raster</strong> also provides <code>plot()</code> methods for its own classes.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(new_raster)</code></pre></div>
<p><img src="figures/basic-new-raster-plot-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>Moreover, it is possible to plot a raster and overlay it with vector data. For this purpose, we need to read-in a vector dataset:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">vector_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;vector/zion.gpkg&quot;</span>, <span class="dt">package=</span><span class="st">&quot;spDataLarge&quot;</span>)
new_vector =<span class="st"> </span><span class="kw">st_read</span>(vector_filepath)</code></pre></div>
<p>Our new object, <code>new_vector</code>, is a polygon representing the borders of Zion National Park (<code>?zion</code>). We can add the borders to the elevation map using the <code>add</code> argument of the <code>plot()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(new_raster)
<span class="kw">plot</span>(new_vector, <span class="dt">add =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p><img src="figures/basic-new-raster-vector-plot-1.png" width="576" style="display: block; margin: auto;" /></p>
<p>There are several different approaches to plot raster data in R:</p>
<ul>
<li>You can use <code>spplot()</code> to visualize several (such as spatiotemporal) layers at once. You can also do so with the <strong>rasterVis</strong> package which provides more advanced methods for plotting raster objects.</li>
<li>Packages such as <strong>tmap</strong>, <strong>mapview</strong> and <strong>leaflet</strong> facilitate especially interactive mapping of both raster and vector objects. <!-- TODO: cross reference advanced mapping chapter --></li>
</ul>
</div>
<div id="raster-classes" class="section level3">
<h3><span class="header-section-number">2.2.3</span> Raster classes</h3>
<p>The <code>RasterLayer</code> class represents the simplest form of a raster object, and consists of only one layer. The easiest way to create a raster object in R is to read-in a raster file from disk or from a server.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">raster_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/srtm.tif&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;spDataLarge&quot;</span>)
new_raster =<span class="st"> </span><span class="kw">raster</span>(raster_filepath)</code></pre></div>
<p>The <strong>raster</strong> package support numerous drivers with the help of <strong>rgdal</strong>. To find out which drivers are available on your system, run <code>raster::writeFormats()</code> and <code>rgdal::gdalDrivers()</code>.</p>
<p>Aside from reading in a raster, you can also create one from scratch. Running <code>raster()</code> creates an empty <code>RasterLayer</code>. Here, however, we will create manually a very simple raster. This should make it easy to understand how raster and related operations work. Our raster should consist of just three rows and columns centered around the null meridian and the equator (see xmn, xmx, ymn and ymx parameters). Additionally, we define a resolution of 0.5, which here corresponds to 0.5 degrees since the default proj4string of a raster object is WGS84. Finally, we set the values with the vals argument. Here, we just number the cells, that means we assign 1 to cell 1, 2 to cell 2, and finally 36 to cell 36. We know that there are 36 cells by multiplying six (rows) by six (columns). As we have seen above, setting raster values in R corresponds to a rowwise cell filling starting at the upper left corner. Consequently, the upper first row contains the values 1 to 6, the second row 7 to 12, and the last row 31 to 36.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># creation of the RasterLayer object with a given number of columns and rows, and extent</span>
new_raster2 =<span class="st"> </span><span class="kw">raster</span>(<span class="dt">nrow =</span> <span class="dv">6</span>, <span class="dt">ncol =</span> <span class="dv">6</span>, <span class="dt">res =</span> <span class="fl">0.5</span>, 
                     <span class="dt">xmn =</span> -<span class="fl">1.5</span>, <span class="dt">xmx =</span> <span class="fl">1.5</span>, <span class="dt">ymn =</span> -<span class="fl">1.5</span>, <span class="dt">ymx =</span> <span class="fl">1.5</span>,
                     <span class="dt">vals =</span> <span class="dv">1</span>:<span class="dv">36</span>)</code></pre></div>
<p>For still further ways of creating a raster object have a look at the help file - <code>?raster</code>. <!--
There are several ways to add new values to the `Raster*` objects.
Values for the whole object could be add with `setValues()`:


```r
# adding random values to the raster object
new_random_values = sample(seq_len(ncell(new_raster4)))
setValues(new_raster4, new_random_values)
```


It is also possible to replace cell values by specifying cell numbers, or row and column numbers:


```r
# change the value of 15th cell to 826
new_raster4[15] = 826
# change the value of the cell in the second row and forth column to 826
new_raster4[2, 4] = 826 
```
--></p>
<p>Aside from <code>RasterLayer</code>, there are two additional classes: <code>RasterBrick</code> and <code>RasterStack</code>. Both can handle multiple layers, but differ regarding the number of supported file formats, type of internal representation and processing speed.</p>
<p>A <code>RasterBrick</code> consists of multiple layers, which typically correspond to a multispectral satellite file. The <code>brick()</code> function creates a <code>RasterBrick</code> object. Usually, you provide it with a filename to a multilayer raster file but might also use another raster object and other spatial objects (see its help page for all supported formats).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">multilayer_raster_filepath =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;raster/landsat.tif&quot;</span>, <span class="dt">package=</span><span class="st">&quot;spDataLarge&quot;</span>)
r_brick =<span class="st"> </span><span class="kw">brick</span>(multilayer_raster_filepath)
r_brick
<span class="co">#&gt; class       : RasterBrick </span>
<span class="co">#&gt; dimensions  : 1428, 1128, 1610784, 4  (nrow, ncol, ncell, nlayers)</span>
<span class="co">#&gt; resolution  : 30, 30  (x, y)</span>
<span class="co">#&gt; extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 </span>
<span class="co">#&gt; data source : /home/travis/R/Library/spDataLarge/raster/landsat.tif </span>
<span class="co">#&gt; names       : landsat.1, landsat.2, landsat.3, landsat.4 </span>
<span class="co">#&gt; min values  :      7550,      6404,      5678,      5252 </span>
<span class="co">#&gt; max values  :     19071,     22051,     25780,     31961</span></code></pre></div>
<p>The <code>nlayers</code> function retrieves the number of layers stored in a <code>Raster*</code> object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nlayers</span>(r_brick)
<span class="co">#&gt; [1] 4</span></code></pre></div>
<p>A <code>RasterStack</code> is similar to a <code>RasterBrick</code> in the sense that it consists also of multiple layers. More specifically, a <code>RasterStack</code> is a list of <code>RasterLayer</code> objects with the same extent and resolution. Hence, one way to create it is with the help of spatial objects already existing in R’s global environment. And again, one can simply specify a path to a file stored on disk. The possibility to create a <code>RasterStack</code> from a file stored on disk and an object residing in R’s global environment is one of the main differences compared to a <code>RasterBrick</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">raster_on_disk =<span class="st"> </span><span class="kw">raster</span>(r_brick, <span class="dt">layer =</span> <span class="dv">1</span>)
raster_in_memory =<span class="st"> </span><span class="kw">raster</span>(<span class="dt">xmn =</span> <span class="dv">301905</span>, <span class="dt">xmx =</span> <span class="dv">335745</span>, <span class="dt">ymn =</span> <span class="dv">4111245</span>, <span class="dt">ymx =</span> <span class="dv">4154085</span>, <span class="dt">res =</span> <span class="dv">30</span>)
<span class="kw">values</span>(raster_in_memory) =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:<span class="kw">ncell</span>(raster_in_memory))
<span class="kw">crs</span>(raster_in_memory) =<span class="st"> </span><span class="kw">crs</span>(raster_on_disk)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">r_stack &lt;-<span class="st"> </span><span class="kw">stack</span>(raster_in_memory, raster_on_disk)
r_stack
<span class="co">#&gt; class       : RasterStack </span>
<span class="co">#&gt; dimensions  : 1428, 1128, 1610784, 2  (nrow, ncol, ncell, nlayers)</span>
<span class="co">#&gt; resolution  : 30, 30  (x, y)</span>
<span class="co">#&gt; extent      : 301905, 335745, 4111245, 4154085  (xmin, xmax, ymin, ymax)</span>
<span class="co">#&gt; coord. ref. : +proj=utm +zone=12 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0 </span>
<span class="co">#&gt; names       :   layer, landsat.1 </span>
<span class="co">#&gt; min values  :       1,      7550 </span>
<span class="co">#&gt; max values  : 1610784,     19071</span></code></pre></div>
<p>Another difference is that the processing time for <code>RasterBrick</code> objects should be usually shorter than for <code>RasterStack</code> objects. Note that operations on <code>RasterBrick</code> and <code>RasterStack</code> objects will typically return a <code>RasterBrick</code>.</p>
</div>
</div>
<div id="crs-intro" class="section level2">
<h2><span class="header-section-number">2.3</span> Coordinate Reference Systems</h2>
<!-- This section is work in progress. -->
<p>Despite the differences between vector and raster spatial data types, they share concepts intrinsic to spatial data. Perhaps the most important of these is the Coordinate Reference System (CRS), which defines how the spatial elements of the data relate to the surface of the Earth (or other bodies). <!-- an intro --> <!-- for operation data needs to have the same projection --> <!-- (for most of the case is better to reproject vector than raster) --></p>
<p>In <strong>sf</strong> the CRS of an object can be retrieved and set using <code>st_crs()</code> and <code>st_set_crs()</code> respectively:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">old_crs =<span class="st"> </span><span class="kw">st_crs</span>(new_vector) <span class="co"># get CRS</span>
old_crs <span class="co"># print CRS</span>
<span class="co">#&gt; $epsg</span>
<span class="co">#&gt; [1] NA</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $proj4string</span>
<span class="co">#&gt; [1] &quot;+proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;crs&quot;</span>
new_vector =<span class="st"> </span><span class="kw">st_set_crs</span>(new_vector, <span class="dv">4326</span>) <span class="co"># set CRS</span>
<span class="co">#&gt; Warning: st_crs&lt;- : replacing crs does not reproject data; use st_transform</span>
<span class="co">#&gt; for that</span></code></pre></div>
<!-- the difference between `st_set_crs()` and `st_transform()` !!! -->
<!-- `st_set_crs()` doesn't change coordinates -->
<!-- vectors: transformation means change of the coordinates of nodes -->
<!-- change shape (no change in attributes) -->
<div class="figure" style="text-align: center"><span id="fig:vector-crs"></span>
<img src="figures/02_vector_crs.png" alt="Examples of projected (left) and geographic (right) coordinate systems for a vector data type" width="765" />
<p class="caption">
Figure 2.9: Examples of projected (left) and geographic (right) coordinate systems for a vector data type
</p>
</div>
<p>Note the warning emitted after the CRS for <code>sf_points</code> was set to <code>27700</code>. This is a good thing: we have imposed a spatial reference onto data without knowing what that means. To discover what the ‘magic number’ <code>27700</code> means, we can retrieve the CRS again:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_crs</span>(new_vector)
<span class="co">#&gt; $epsg</span>
<span class="co">#&gt; [1] 4326</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $proj4string</span>
<span class="co">#&gt; [1] &quot;+proj=longlat +datum=WGS84 +no_defs&quot;</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; attr(,&quot;class&quot;)</span>
<span class="co">#&gt; [1] &quot;crs&quot;</span></code></pre></div>
<!-- rasters: transformation means change of the coordinates of (special case of resampling) -->
<!-- changes in dimensions, resolution, extent -->
<!-- change shape and attributes) -->
<!-- different methods of computing values after transformation, such as ngb or bilinear  -->
<div class="figure" style="text-align: center"><span id="fig:raster-crs"></span>
<img src="figures/02_raster_crs.png" alt="Examples of projected (left) and geographic (right) coordinate systems for a raster data type" width="475" />
<p class="caption">
Figure 2.10: Examples of projected (left) and geographic (right) coordinate systems for a raster data type
</p>
</div>
<!-- reference to the 6th chapter -->
<!--(see Chapter \@ref(coord) for more on CRSs)-->
</div>
<div id="units" class="section level2">
<h2><span class="header-section-number">2.4</span> Units</h2>
<!-- https://cran.r-project.org/web/packages/units/vignettes/measurement_units_in_R.html -->
<p>An important feature of CRSs is that they contain information about spatial units. Clearly it is vital to know whether a house’s measurements are in feet or meters, and the same applies to maps. It is good cartographic practice to add a <em>scale bar</em> onto maps to demonstrate the relationship between distances on the page or screen and distances on the ground. Likewise, it is important to formally specify the units in which the geometry data or pixels are measured to provide context, and ensure that subsequent calculations are done in context.</p>
<p>A novel feature of geometry data in <code>sf</code> objects is that they have <em>native support</em> for units. This means that distance, area and other geometric calculations in <strong>sf</strong> return values that come with a <code>units</code> attribute, defined by the <strong>units</strong> package <span class="citation">(Pebesma, Mailund, and Hiebert <a href="#ref-pebesma_measurement_2016">2016</a>)</span>. This is advantageous because it prevents confusion caused by the fact that different CRSs use different units (most use meters, some use feet). Furthermore, it also provides information on dimensionality, as illustrated by the following calculation which reports the area of Nigeria:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">nigeria =<span class="st"> </span>world[world$name_long ==<span class="st"> &quot;Nigeria&quot;</span>, ]</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_area</span>(nigeria)
<span class="co">#&gt; 9.05e+11 m^2</span></code></pre></div>
<p>The result is in units of square meters (m<sup>2</sup>), showing a) that the result represents two-dimensional space and b) and that Nigeria is a large country! This information, stored as an attribute (which interested readers can discover with <code>attributes(st_area(nigeria))</code>) is advantageous for many reasons, for example it could feed into subsequent calculations such as population density. Reporting units prevents confusion. To take the Nigeria example, if the units remained unspecified, one could incorrectly assume that the units were in km<sup>2</sup>. To translate the huge number into a more digestible size, it is tempting to divide the results by a million (the number of square meters in a square kilometer):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">st_area</span>(nigeria) /<span class="st"> </span><span class="fl">1e6</span>
<span class="co">#&gt; 905072 m^2</span></code></pre></div>
<p>However, the result is incorrectly given again as square meters. The solution is to set the correct units with the <strong>units</strong> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">units::<span class="kw">set_units</span>(<span class="kw">st_area</span>(nigeria), km^<span class="dv">2</span>)
<span class="co">#&gt; 905072 km^2</span></code></pre></div>
<!-- Is that right? I mean, the units DESCRIPTION says "Support for measurement units in R vectors, matrices and arrays". Since raster datasets are just matrixes, units might be easily used with them?-->
<p>Units are of equal importance in the case of raster data. However, so far <strong>sf</strong> is the only spatial package that supports units, meaning that people working on raster data should approach changes in the units of analysis (e.g., converting pixel widths from imperial to decimal units) with care. The <code>new_raster</code> object (see above) uses a UTM projection with meters as units. Consequently, its resolution is also given in meters but you have to know it, since the <code>res()</code> function simply returns a numeric vector.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">res</span>(new_raster)
<span class="co">#&gt; [1] 73.7 92.5</span></code></pre></div>
<p>If we used the WGS84 projection, the units would change.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(rgdal)
repr =<span class="st"> </span><span class="kw">projectRaster</span>(new_raster, <span class="dt">crs =</span> <span class="st">&quot;+init=epsg:4326&quot;</span>)
<span class="kw">res</span>(repr)
<span class="co">#&gt; [1] 0.000831 0.000833</span></code></pre></div>
<p>Again, the <code>res()</code> command gives back a numeric vector without any unit, forcing us to know that the unit of the WGS84 projection is decimal degrees.</p>
<!-- Something about when units are not set: -->
<!-- ```{r} -->
<!-- st_distance(sf_point1, sf_point2) -->
<!-- ``` -->
<!-- ## Precision -->
</div>
<div id="exercises-1" class="section level2">
<h2><span class="header-section-number">2.5</span> Exercises</h2>
<ol style="list-style-type: decimal">
<li>What does the summary of the <code>geometry</code> column tell us about the <code>world</code> dataset, in terms of:</li>
</ol>
<ul>
<li>The geometry type?</li>
<li>How many countries there are?</li>
<li>The coordinate reference system (CRS)?</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>Using <strong>sf</strong>’s <code>plot()</code> command, create a map of Nigeria in context, building on the code that creates and plots Asia above (see Figure <a href="spatial-class.html#fig:asia">2.5</a> for an example of what this could look like).</li>
</ol>
<ul>
<li>Hint: this used the <code>lwd</code>, <code>main</code> and <code>col</code> arguments of <code>plot()</code>.</li>
<li>Bonus: make the country boundaries a dotted grey line.</li>
<li>Hint: <code>border</code> is an additional argument of <code>plot()</code> for <strong>sf</strong> objects.</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>Exercise 3 <!--missing title--></li>
</ol>
<ul>
<li>What does the <code>lwd</code> argument do in the <code>plot()</code> code that generates Figure <a href="spatial-class.html#fig:africa">2.6</a>.</li>
<li>Perform the same operations and map making for another continent of your choice.</li>
<li>Bonus: Download some global geographic data and add attribute variables assigning them to the continents of the world.</li>
</ul>
<!-- raster exercises -->
<!-- crs exercises -->
<!-- units exercises -->

</div>
</div>
<h3> References</h3>
<div id="refs" class="references">
<div id="ref-gillespie_efficient_2016">
<p>Gillespie, Colin, and Robin Lovelace. 2016. <em>Efficient R Programming: A Practical Guide to Smarter Programming</em>. O’Reilly Media. <a href="https://csgillespie.github.io/efficientR/" class="uri">https://csgillespie.github.io/efficientR/</a>.</p>
</div>
<div id="ref-grolemund_r_2016">
<p>Grolemund, Garrett, and Hadley Wickham. 2016. <em>R for Data Science</em>. 1 edition. O’Reilly Media.</p>
</div>
<div id="ref-longley_geographic_2015">
<p>Longley, Paul. 2015. <em>Geographic Information Science &amp; Systems</em>. Fourth edition. Hoboken, NJ: Wiley.</p>
</div>
<div id="ref-R-sf">
<p>Pebesma, Edzer. 2017. <em>Sf: Simple Features for R</em>. <a href="https://CRAN.R-project.org/package=sf" class="uri">https://CRAN.R-project.org/package=sf</a>.</p>
</div>
<div id="ref-R-sp">
<p>Pebesma, Edzer, and Roger Bivand. 2017. <em>Sp: Classes and Methods for Spatial Data</em>. <a href="https://CRAN.R-project.org/package=sp" class="uri">https://CRAN.R-project.org/package=sp</a>.</p>
</div>
<div id="ref-R-rgdal">
<p>Bivand, Roger, Tim Keitt, and Barry Rowlingson. 2017. <em>Rgdal: Bindings for the Geospatial Data Abstraction Library</em>. <a href="https://CRAN.R-project.org/package=rgdal" class="uri">https://CRAN.R-project.org/package=rgdal</a>.</p>
</div>
<div id="ref-R-rgeos">
<p>Bivand, Roger, and Colin Rundel. 2017. <em>Rgeos: Interface to Geometry Engine - Open Source (GEOS)</em>. <a href="https://CRAN.R-project.org/package=rgeos" class="uri">https://CRAN.R-project.org/package=rgeos</a>.</p>
</div>
<div id="ref-bivand_applied_2013">
<p>Bivand, Roger, Edzer J Pebesma, and Virgilio Gómez-Rubio. 2013. <em>Applied Spatial Data Analysis with R</em>. Vol. 747248717. Springer.</p>
</div>
<div id="ref-pebesma_measurement_2016">
<p>Pebesma, Edzer, Thomas Mailund, and James Hiebert. 2016. “Measurement Units in R.” <em>The R Journal</em> 8 (2): 486–94. <a href="https://journal.r-project.org/archive/2016-2/pebesma-mailund-hiebert.pdf" class="uri">https://journal.r-project.org/archive/2016-2/pebesma-mailund-hiebert.pdf</a>.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol start="12">
<li id="fn12"><p>Please do not confuse the geographic data vector model with R’s <code>vector</code> class. The latter is a data format in R such as <code>data.frame</code> and <code>matrix</code>. However, we can represent spatial coordinates, which are part of the geographic vector data model, using R’s <code>vector</code> class.<a href="spatial-class.html#fnref12">↩</a></p></li>
<li id="fn13"><p>In 3 dimensional coordinate systems three numbers are needed for each of the three axes, <span class="math inline">\(x\)</span>, <span class="math inline">\(y\)</span> and <span class="math inline">\(z\)</span>.<a href="spatial-class.html#fnref13">↩</a></p></li>
<li id="fn14"><p>Other methods for generating numbers include with the <code>seq()</code> function (short for ‘sequence’) for generating regular sequences or <code>runif()</code>, <code>rnorm()</code> and other functions generating random numbers following some kind of probability distribution. The <strong>mapedit</strong> package can be used to create spatial data manually on an interactive map.<a href="spatial-class.html#fnref14">↩</a></p></li>
<li id="fn15"><p>The full OGC standard includes rather exotic geometry types including ‘surface’ and ‘curve’ geometry types, which currently have limited application in real world applications. All 68 types can be represented in R, although (at the time of writing) all methods, such as plotting, are only supported for the 7 types that are used.<a href="spatial-class.html#fnref15">↩</a></p></li>
<li id="fn16"><p>The development version, which may contain new features, can be installed with <code>devtools::install_github(&quot;r-spatial/sf&quot;).</code><a href="spatial-class.html#fnref16">↩</a></p></li>
<li id="fn17"><p>In fact, when you <code>plot()</code> an <strong>sf</strong> object, R is calling <code>sf:::plot.sf()</code> behind the scenes. <code>plot()</code> is a generic method that behaves differently depending on the class of object being plotted.<a href="spatial-class.html#fnref17">↩</a></p></li>
<li id="fn18"><p>In the background, <code>sf</code> uses the <a href="http://proj4.org/">PROJ.4</a> software, which enables transformations between different projections<a href="spatial-class.html#fnref18">↩</a></p></li>
</ol>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="intro.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="attr.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Robinlovelace/geocompr/edit/master/02-spatial-data.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
